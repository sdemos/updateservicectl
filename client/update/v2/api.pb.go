// Code generated by protoc-gen-gogo.
// source: api.proto
// DO NOT EDIT!

/*
	Package update is a generated protocol buffer package.

	It is generated from these files:
		api.proto

	It has these top-level messages:
		User
		App
		Channel
		Group
		Package
		Upstream
		CreateUserReq
		CreateUserResp
		ListUsersReq
		ListUsersResp
		GetUserReq
		GetUserResp
		DeleteUserReq
		DeleteUserResp
		GenerateUserTokenReq
		GenerateUserTokenResp
		CreateAppReq
		CreateAppResp
		ListAppsReq
		ListAppsResp
		GetAppReq
		GetAppResp
		DeleteAppReq
		DeleteAppResp
		SetAppLabelReq
		SetAppLabelResp
		SetAppDescriptionReq
		SetAppDescriptionResp
		CreateChannelReq
		CreateChannelResp
		ListChannelsReq
		ListChannelsResp
		GetChannelReq
		GetChannelResp
		DeleteChannelReq
		DeleteChannelResp
		SetChannelLabelReq
		SetChannelLabelResp
		SetChannelVersionReq
		SetChannelVersionResp
		SetChannelPublishReq
		SetChannelPublishResp
		SetChannelUpstreamReq
		SetChannelUpstreamResp
		DeleteChannelUpstreamReq
		DeleteChannelUpstreamResp
		CreateGroupReq
		CreateGroupResp
		ListGroupsReq
		ListGroupsResp
		GetGroupReq
		GetGroupResp
		DeleteGroupReq
		DeleteGroupResp
		SetGroupChannelIDReq
		SetGroupChannelIDResp
		SetGroupLabelReq
		SetGroupLabelResp
		SetGroupUpdateCountReq
		SetGroupUpdateCountResp
		SetGroupUpdateIntervalReq
		SetGroupUpdateIntervalResp
		SetGroupUpdatesPausedStateReq
		SetGroupUpdatesPausedStateResp
		SetGroupUpdatePoolingReq
		SetGroupUpdatePoolingResp
		SetGroupOEMBlacklistReq
		SetGroupOEMBlacklistResp
		GroupRequestsValues
		GetGroupVersionsRollupReq
		GroupVersionsItem
		GetGroupVersionsRollupResp
		GetGroupEventsRollupReq
		GroupEventsItem
		GetGroupEventsRollupResp
		CreatePackageReq
		CreatePackageResp
		ListPackagesReq
		ListPackagesResp
		GetPackageReq
		GetPackageResp
		DeletePackageReq
		DeletePackageResp
		CreateUpstreamReq
		CreateUpstreamResp
		ListUpstreamsReq
		ListUpstreamsResp
		GetUpstreamReq
		GetUpstreamResp
		DeleteUpstreamReq
		DeleteUpstreamResp
		SyncUpstreamsReq
		SyncUpstreamsResp
		SetUpstreamURLReq
		SetUpstreamURLResp
		SetUpstreamLabelReq
		SetUpstreamLabelResp
		GetClientHistoryReq
		GetClientHistoryItem
		GetClientHistoryResp
		ListAppVersionsReq
		AppVersionItem
		ListAppVersionsResp
		ListClientUpdatesReq
		ClientUpdate
		ListClientUpdatesResp
		GetClientUpdateCountReq
		GetClientUpdateCountResp
		GenerateUUIDReq
		GenerateUUIDResp
*/
package update

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import _ "github.com/gengo/grpc-gateway/third_party/googleapis/google/api"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type User struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username"`
	Token    string `protobuf:"bytes,2,opt,name=token,proto3" json:"token"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{0} }

type App struct {
	ID          string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Label       string `protobuf:"bytes,2,opt,name=label,proto3" json:"label"`
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description"`
}

func (m *App) Reset()                    { *m = App{} }
func (m *App) String() string            { return proto.CompactTextString(m) }
func (*App) ProtoMessage()               {}
func (*App) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{1} }

type Channel struct {
	ID         string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	AppID      string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"appID"`
	Label      string `protobuf:"bytes,3,opt,name=label,proto3" json:"label"`
	Version    string `protobuf:"bytes,4,opt,name=version,proto3" json:"version"`
	Publish    bool   `protobuf:"varint,5,opt,name=publish,proto3" json:"publish"`
	UpstreamID string `protobuf:"bytes,6,opt,name=upstream_id,json=upstreamId,proto3" json:"upstreamID"`
	CreatedAt  string `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"createdAt"`
}

func (m *Channel) Reset()                    { *m = Channel{} }
func (m *Channel) String() string            { return proto.CompactTextString(m) }
func (*Channel) ProtoMessage()               {}
func (*Channel) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{2} }

type Group struct {
	ID             string `protobuf:"bytes,1,opt,name=group_id,json=groupId,proto3" json:"id"`
	AppID          string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"appID"`
	ChannelID      string `protobuf:"bytes,3,opt,name=channel_id,json=channelId,proto3" json:"channelID"`
	Label          string `protobuf:"bytes,4,opt,name=label,proto3" json:"label"`
	UpdateCount    int64  `protobuf:"varint,5,opt,name=update_count,json=updateCount,proto3" json:"updateCount"`
	UpdateInterval int64  `protobuf:"varint,6,opt,name=update_interval,json=updateInterval,proto3" json:"updateInterval"`
	UpdatesPaused  bool   `protobuf:"varint,7,opt,name=updates_paused,json=updatesPaused,proto3" json:"updatesPaused"`
	UpdatePooling  bool   `protobuf:"varint,8,opt,name=update_pooling,json=updatePooling,proto3" json:"updatePooling"`
	OEMBlacklist   string `protobuf:"bytes,9,opt,name=oem_blacklist,json=oemBlacklist,proto3" json:"oemBlacklist"`
}

func (m *Group) Reset()                    { *m = Group{} }
func (m *Group) String() string            { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()               {}
func (*Group) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{3} }

type Package struct {
	AppID                string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"appID"`
	Version              string `protobuf:"bytes,2,opt,name=version,proto3" json:"version"`
	URL                  string `protobuf:"bytes,3,opt,name=url,proto3" json:"url"`
	Size_                string `protobuf:"bytes,4,opt,name=size,proto3" json:"size"`
	Sha1Sum              string `protobuf:"bytes,5,opt,name=sha1_sum,json=sha1Sum,proto3" json:"sha1Sum"`
	Sha256Sum            string `protobuf:"bytes,6,opt,name=sha256_sum,json=sha256Sum,proto3" json:"sha256Sum"`
	Required             bool   `protobuf:"varint,7,opt,name=required,proto3" json:"required"`
	MetadataSignatureRsa string `protobuf:"bytes,8,opt,name=metadata_signature_rsa,json=metadataSignatureRsa,proto3" json:"metadataSignatureRsa"`
	MetadataSize         string `protobuf:"bytes,9,opt,name=metadata_size,json=metadataSize,proto3" json:"metadataSize"`
	CreatedAt            string `protobuf:"bytes,10,opt,name=created_at,json=createdAt,proto3" json:"createdAt"`
	ReleaseNotes         string `protobuf:"bytes,11,opt,name=release_notes,json=releaseNotes,proto3" json:"releaseNotes"`
}

func (m *Package) Reset()                    { *m = Package{} }
func (m *Package) String() string            { return proto.CompactTextString(m) }
func (*Package) ProtoMessage()               {}
func (*Package) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{4} }

type Upstream struct {
	ID    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	URL   string `protobuf:"bytes,2,opt,name=url,proto3" json:"url"`
	Label string `protobuf:"bytes,3,opt,name=label,proto3" json:"label"`
}

func (m *Upstream) Reset()                    { *m = Upstream{} }
func (m *Upstream) String() string            { return proto.CompactTextString(m) }
func (*Upstream) ProtoMessage()               {}
func (*Upstream) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{5} }

type CreateUserReq struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username"`
}

func (m *CreateUserReq) Reset()                    { *m = CreateUserReq{} }
func (m *CreateUserReq) String() string            { return proto.CompactTextString(m) }
func (*CreateUserReq) ProtoMessage()               {}
func (*CreateUserReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{6} }

type CreateUserResp struct {
	User *User `protobuf:"bytes,1,opt,name=user" json:"user"`
}

func (m *CreateUserResp) Reset()                    { *m = CreateUserResp{} }
func (m *CreateUserResp) String() string            { return proto.CompactTextString(m) }
func (*CreateUserResp) ProtoMessage()               {}
func (*CreateUserResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{7} }

func (m *CreateUserResp) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

type ListUsersReq struct {
}

func (m *ListUsersReq) Reset()                    { *m = ListUsersReq{} }
func (m *ListUsersReq) String() string            { return proto.CompactTextString(m) }
func (*ListUsersReq) ProtoMessage()               {}
func (*ListUsersReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{8} }

type ListUsersResp struct {
	Items []*User `protobuf:"bytes,1,rep,name=items" json:"users"`
}

func (m *ListUsersResp) Reset()                    { *m = ListUsersResp{} }
func (m *ListUsersResp) String() string            { return proto.CompactTextString(m) }
func (*ListUsersResp) ProtoMessage()               {}
func (*ListUsersResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{9} }

func (m *ListUsersResp) GetItems() []*User {
	if m != nil {
		return m.Items
	}
	return nil
}

type GetUserReq struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username"`
}

func (m *GetUserReq) Reset()                    { *m = GetUserReq{} }
func (m *GetUserReq) String() string            { return proto.CompactTextString(m) }
func (*GetUserReq) ProtoMessage()               {}
func (*GetUserReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{10} }

type GetUserResp struct {
	User *User `protobuf:"bytes,1,opt,name=user" json:"user"`
}

func (m *GetUserResp) Reset()                    { *m = GetUserResp{} }
func (m *GetUserResp) String() string            { return proto.CompactTextString(m) }
func (*GetUserResp) ProtoMessage()               {}
func (*GetUserResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{11} }

func (m *GetUserResp) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

type DeleteUserReq struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username"`
}

func (m *DeleteUserReq) Reset()                    { *m = DeleteUserReq{} }
func (m *DeleteUserReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteUserReq) ProtoMessage()               {}
func (*DeleteUserReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{12} }

type DeleteUserResp struct {
}

func (m *DeleteUserResp) Reset()                    { *m = DeleteUserResp{} }
func (m *DeleteUserResp) String() string            { return proto.CompactTextString(m) }
func (*DeleteUserResp) ProtoMessage()               {}
func (*DeleteUserResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{13} }

type GenerateUserTokenReq struct {
	Username string `protobuf:"bytes,1,opt,name=username,proto3" json:"username"`
}

func (m *GenerateUserTokenReq) Reset()                    { *m = GenerateUserTokenReq{} }
func (m *GenerateUserTokenReq) String() string            { return proto.CompactTextString(m) }
func (*GenerateUserTokenReq) ProtoMessage()               {}
func (*GenerateUserTokenReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{14} }

type GenerateUserTokenResp struct {
	User *User `protobuf:"bytes,1,opt,name=user" json:"user"`
}

func (m *GenerateUserTokenResp) Reset()                    { *m = GenerateUserTokenResp{} }
func (m *GenerateUserTokenResp) String() string            { return proto.CompactTextString(m) }
func (*GenerateUserTokenResp) ProtoMessage()               {}
func (*GenerateUserTokenResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{15} }

func (m *GenerateUserTokenResp) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

type CreateAppReq struct {
	ID          string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Label       string `protobuf:"bytes,2,opt,name=label,proto3" json:"label"`
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description"`
}

func (m *CreateAppReq) Reset()                    { *m = CreateAppReq{} }
func (m *CreateAppReq) String() string            { return proto.CompactTextString(m) }
func (*CreateAppReq) ProtoMessage()               {}
func (*CreateAppReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{16} }

type CreateAppResp struct {
	App *App `protobuf:"bytes,1,opt,name=app" json:"app"`
}

func (m *CreateAppResp) Reset()                    { *m = CreateAppResp{} }
func (m *CreateAppResp) String() string            { return proto.CompactTextString(m) }
func (*CreateAppResp) ProtoMessage()               {}
func (*CreateAppResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{17} }

func (m *CreateAppResp) GetApp() *App {
	if m != nil {
		return m.App
	}
	return nil
}

type ListAppsReq struct {
}

func (m *ListAppsReq) Reset()                    { *m = ListAppsReq{} }
func (m *ListAppsReq) String() string            { return proto.CompactTextString(m) }
func (*ListAppsReq) ProtoMessage()               {}
func (*ListAppsReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{18} }

type ListAppsResp struct {
	Items []*App `protobuf:"bytes,1,rep,name=items" json:"items"`
}

func (m *ListAppsResp) Reset()                    { *m = ListAppsResp{} }
func (m *ListAppsResp) String() string            { return proto.CompactTextString(m) }
func (*ListAppsResp) ProtoMessage()               {}
func (*ListAppsResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{19} }

func (m *ListAppsResp) GetItems() []*App {
	if m != nil {
		return m.Items
	}
	return nil
}

type GetAppReq struct {
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
}

func (m *GetAppReq) Reset()                    { *m = GetAppReq{} }
func (m *GetAppReq) String() string            { return proto.CompactTextString(m) }
func (*GetAppReq) ProtoMessage()               {}
func (*GetAppReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{20} }

type GetAppResp struct {
	App *App `protobuf:"bytes,1,opt,name=app" json:"app"`
}

func (m *GetAppResp) Reset()                    { *m = GetAppResp{} }
func (m *GetAppResp) String() string            { return proto.CompactTextString(m) }
func (*GetAppResp) ProtoMessage()               {}
func (*GetAppResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{21} }

func (m *GetAppResp) GetApp() *App {
	if m != nil {
		return m.App
	}
	return nil
}

type DeleteAppReq struct {
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
}

func (m *DeleteAppReq) Reset()                    { *m = DeleteAppReq{} }
func (m *DeleteAppReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteAppReq) ProtoMessage()               {}
func (*DeleteAppReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{22} }

type DeleteAppResp struct {
}

func (m *DeleteAppResp) Reset()                    { *m = DeleteAppResp{} }
func (m *DeleteAppResp) String() string            { return proto.CompactTextString(m) }
func (*DeleteAppResp) ProtoMessage()               {}
func (*DeleteAppResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{23} }

type SetAppLabelReq struct {
	ID    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Label string `protobuf:"bytes,2,opt,name=label,proto3" json:"label"`
}

func (m *SetAppLabelReq) Reset()                    { *m = SetAppLabelReq{} }
func (m *SetAppLabelReq) String() string            { return proto.CompactTextString(m) }
func (*SetAppLabelReq) ProtoMessage()               {}
func (*SetAppLabelReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{24} }

type SetAppLabelResp struct {
	App *App `protobuf:"bytes,1,opt,name=app" json:"app"`
}

func (m *SetAppLabelResp) Reset()                    { *m = SetAppLabelResp{} }
func (m *SetAppLabelResp) String() string            { return proto.CompactTextString(m) }
func (*SetAppLabelResp) ProtoMessage()               {}
func (*SetAppLabelResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{25} }

func (m *SetAppLabelResp) GetApp() *App {
	if m != nil {
		return m.App
	}
	return nil
}

type SetAppDescriptionReq struct {
	ID          string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description"`
}

func (m *SetAppDescriptionReq) Reset()                    { *m = SetAppDescriptionReq{} }
func (m *SetAppDescriptionReq) String() string            { return proto.CompactTextString(m) }
func (*SetAppDescriptionReq) ProtoMessage()               {}
func (*SetAppDescriptionReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{26} }

type SetAppDescriptionResp struct {
	App *App `protobuf:"bytes,1,opt,name=app" json:"app"`
}

func (m *SetAppDescriptionResp) Reset()                    { *m = SetAppDescriptionResp{} }
func (m *SetAppDescriptionResp) String() string            { return proto.CompactTextString(m) }
func (*SetAppDescriptionResp) ProtoMessage()               {}
func (*SetAppDescriptionResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{27} }

func (m *SetAppDescriptionResp) GetApp() *App {
	if m != nil {
		return m.App
	}
	return nil
}

type CreateChannelReq struct {
	Label      string `protobuf:"bytes,1,opt,name=label,proto3" json:"label"`
	AppID      string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"appID"`
	Version    string `protobuf:"bytes,3,opt,name=version,proto3" json:"version"`
	Publish    bool   `protobuf:"varint,4,opt,name=publish,proto3" json:"publish"`
	UpstreamID string `protobuf:"bytes,5,opt,name=upstream_id,json=upstreamId,proto3" json:"upstreamID"`
}

func (m *CreateChannelReq) Reset()                    { *m = CreateChannelReq{} }
func (m *CreateChannelReq) String() string            { return proto.CompactTextString(m) }
func (*CreateChannelReq) ProtoMessage()               {}
func (*CreateChannelReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{28} }

type CreateChannelResp struct {
	Channel *Channel `protobuf:"bytes,1,opt,name=channel" json:"channel"`
}

func (m *CreateChannelResp) Reset()                    { *m = CreateChannelResp{} }
func (m *CreateChannelResp) String() string            { return proto.CompactTextString(m) }
func (*CreateChannelResp) ProtoMessage()               {}
func (*CreateChannelResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{29} }

func (m *CreateChannelResp) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type ListChannelsReq struct {
	AppID string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"appID"`
}

func (m *ListChannelsReq) Reset()                    { *m = ListChannelsReq{} }
func (m *ListChannelsReq) String() string            { return proto.CompactTextString(m) }
func (*ListChannelsReq) ProtoMessage()               {}
func (*ListChannelsReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{30} }

type ListChannelsResp struct {
	Items []*Channel `protobuf:"bytes,1,rep,name=items" json:"items"`
}

func (m *ListChannelsResp) Reset()                    { *m = ListChannelsResp{} }
func (m *ListChannelsResp) String() string            { return proto.CompactTextString(m) }
func (*ListChannelsResp) ProtoMessage()               {}
func (*ListChannelsResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{31} }

func (m *ListChannelsResp) GetItems() []*Channel {
	if m != nil {
		return m.Items
	}
	return nil
}

type GetChannelReq struct {
	ChannelID string `protobuf:"bytes,1,opt,name=id,proto3" json:"channelID"`
}

func (m *GetChannelReq) Reset()                    { *m = GetChannelReq{} }
func (m *GetChannelReq) String() string            { return proto.CompactTextString(m) }
func (*GetChannelReq) ProtoMessage()               {}
func (*GetChannelReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{32} }

type GetChannelResp struct {
	Channel *Channel `protobuf:"bytes,1,opt,name=channel" json:"channel"`
}

func (m *GetChannelResp) Reset()                    { *m = GetChannelResp{} }
func (m *GetChannelResp) String() string            { return proto.CompactTextString(m) }
func (*GetChannelResp) ProtoMessage()               {}
func (*GetChannelResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{33} }

func (m *GetChannelResp) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type DeleteChannelReq struct {
	ChannelID string `protobuf:"bytes,1,opt,name=id,proto3" json:"channelID"`
}

func (m *DeleteChannelReq) Reset()                    { *m = DeleteChannelReq{} }
func (m *DeleteChannelReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteChannelReq) ProtoMessage()               {}
func (*DeleteChannelReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{34} }

type DeleteChannelResp struct {
}

func (m *DeleteChannelResp) Reset()                    { *m = DeleteChannelResp{} }
func (m *DeleteChannelResp) String() string            { return proto.CompactTextString(m) }
func (*DeleteChannelResp) ProtoMessage()               {}
func (*DeleteChannelResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{35} }

type SetChannelLabelReq struct {
	ID    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Label string `protobuf:"bytes,2,opt,name=label,proto3" json:"label"`
}

func (m *SetChannelLabelReq) Reset()                    { *m = SetChannelLabelReq{} }
func (m *SetChannelLabelReq) String() string            { return proto.CompactTextString(m) }
func (*SetChannelLabelReq) ProtoMessage()               {}
func (*SetChannelLabelReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{36} }

type SetChannelLabelResp struct {
	Channel *Channel `protobuf:"bytes,1,opt,name=channel" json:"channel"`
}

func (m *SetChannelLabelResp) Reset()                    { *m = SetChannelLabelResp{} }
func (m *SetChannelLabelResp) String() string            { return proto.CompactTextString(m) }
func (*SetChannelLabelResp) ProtoMessage()               {}
func (*SetChannelLabelResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{37} }

func (m *SetChannelLabelResp) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type SetChannelVersionReq struct {
	ID      string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version"`
}

func (m *SetChannelVersionReq) Reset()                    { *m = SetChannelVersionReq{} }
func (m *SetChannelVersionReq) String() string            { return proto.CompactTextString(m) }
func (*SetChannelVersionReq) ProtoMessage()               {}
func (*SetChannelVersionReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{38} }

type SetChannelVersionResp struct {
	Channel *Channel `protobuf:"bytes,1,opt,name=channel" json:"channel"`
}

func (m *SetChannelVersionResp) Reset()                    { *m = SetChannelVersionResp{} }
func (m *SetChannelVersionResp) String() string            { return proto.CompactTextString(m) }
func (*SetChannelVersionResp) ProtoMessage()               {}
func (*SetChannelVersionResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{39} }

func (m *SetChannelVersionResp) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type SetChannelPublishReq struct {
	ID      string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Publish bool   `protobuf:"varint,2,opt,name=publish,proto3" json:"publish"`
}

func (m *SetChannelPublishReq) Reset()                    { *m = SetChannelPublishReq{} }
func (m *SetChannelPublishReq) String() string            { return proto.CompactTextString(m) }
func (*SetChannelPublishReq) ProtoMessage()               {}
func (*SetChannelPublishReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{40} }

type SetChannelPublishResp struct {
	Channel *Channel `protobuf:"bytes,1,opt,name=channel" json:"channel"`
}

func (m *SetChannelPublishResp) Reset()                    { *m = SetChannelPublishResp{} }
func (m *SetChannelPublishResp) String() string            { return proto.CompactTextString(m) }
func (*SetChannelPublishResp) ProtoMessage()               {}
func (*SetChannelPublishResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{41} }

func (m *SetChannelPublishResp) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type SetChannelUpstreamReq struct {
	ID         string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	UpstreamId string `protobuf:"bytes,2,opt,name=upstream_id,json=upstreamId,proto3" json:"upstreamID"`
}

func (m *SetChannelUpstreamReq) Reset()                    { *m = SetChannelUpstreamReq{} }
func (m *SetChannelUpstreamReq) String() string            { return proto.CompactTextString(m) }
func (*SetChannelUpstreamReq) ProtoMessage()               {}
func (*SetChannelUpstreamReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{42} }

type SetChannelUpstreamResp struct {
	Channel *Channel `protobuf:"bytes,1,opt,name=channel" json:"channel"`
}

func (m *SetChannelUpstreamResp) Reset()                    { *m = SetChannelUpstreamResp{} }
func (m *SetChannelUpstreamResp) String() string            { return proto.CompactTextString(m) }
func (*SetChannelUpstreamResp) ProtoMessage()               {}
func (*SetChannelUpstreamResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{43} }

func (m *SetChannelUpstreamResp) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type DeleteChannelUpstreamReq struct {
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
}

func (m *DeleteChannelUpstreamReq) Reset()                    { *m = DeleteChannelUpstreamReq{} }
func (m *DeleteChannelUpstreamReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteChannelUpstreamReq) ProtoMessage()               {}
func (*DeleteChannelUpstreamReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{44} }

type DeleteChannelUpstreamResp struct {
	Channel *Channel `protobuf:"bytes,1,opt,name=channel" json:"channel"`
}

func (m *DeleteChannelUpstreamResp) Reset()                    { *m = DeleteChannelUpstreamResp{} }
func (m *DeleteChannelUpstreamResp) String() string            { return proto.CompactTextString(m) }
func (*DeleteChannelUpstreamResp) ProtoMessage()               {}
func (*DeleteChannelUpstreamResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{45} }

func (m *DeleteChannelUpstreamResp) GetChannel() *Channel {
	if m != nil {
		return m.Channel
	}
	return nil
}

type CreateGroupReq struct {
	ID             string `protobuf:"bytes,1,opt,name=group_id,json=groupId,proto3" json:"id"`
	AppID          string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"appID"`
	ChannelID      string `protobuf:"bytes,3,opt,name=channel_id,json=channelId,proto3" json:"channelID"`
	Label          string `protobuf:"bytes,4,opt,name=label,proto3" json:"label"`
	UpdateCount    int64  `protobuf:"varint,5,opt,name=update_count,json=updateCount,proto3" json:"updateCount"`
	UpdateInterval int64  `protobuf:"varint,6,opt,name=update_interval,json=updateInterval,proto3" json:"updateInterval"`
	UpdatesPaused  bool   `protobuf:"varint,7,opt,name=updates_paused,json=updatesPaused,proto3" json:"updatesPaused"`
	UpdatePooling  bool   `protobuf:"varint,8,opt,name=update_pooling,json=updatePooling,proto3" json:"updatePooling"`
	OEMBlacklist   string `protobuf:"bytes,9,opt,name=oem_blacklist,json=oemBlacklist,proto3" json:"oemBlacklist"`
}

func (m *CreateGroupReq) Reset()                    { *m = CreateGroupReq{} }
func (m *CreateGroupReq) String() string            { return proto.CompactTextString(m) }
func (*CreateGroupReq) ProtoMessage()               {}
func (*CreateGroupReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{46} }

type CreateGroupResp struct {
	Group *Group `protobuf:"bytes,1,opt,name=group" json:"group"`
}

func (m *CreateGroupResp) Reset()                    { *m = CreateGroupResp{} }
func (m *CreateGroupResp) String() string            { return proto.CompactTextString(m) }
func (*CreateGroupResp) ProtoMessage()               {}
func (*CreateGroupResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{47} }

func (m *CreateGroupResp) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type ListGroupsReq struct {
	AppID string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"appID"`
}

func (m *ListGroupsReq) Reset()                    { *m = ListGroupsReq{} }
func (m *ListGroupsReq) String() string            { return proto.CompactTextString(m) }
func (*ListGroupsReq) ProtoMessage()               {}
func (*ListGroupsReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{48} }

type ListGroupsResp struct {
	Items []*Group `protobuf:"bytes,1,rep,name=items" json:"items"`
}

func (m *ListGroupsResp) Reset()                    { *m = ListGroupsResp{} }
func (m *ListGroupsResp) String() string            { return proto.CompactTextString(m) }
func (*ListGroupsResp) ProtoMessage()               {}
func (*ListGroupsResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{49} }

func (m *ListGroupsResp) GetItems() []*Group {
	if m != nil {
		return m.Items
	}
	return nil
}

type GetGroupReq struct {
	ID    string `protobuf:"bytes,1,opt,name=group_id,json=groupId,proto3" json:"id"`
	AppID string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"appID"`
}

func (m *GetGroupReq) Reset()                    { *m = GetGroupReq{} }
func (m *GetGroupReq) String() string            { return proto.CompactTextString(m) }
func (*GetGroupReq) ProtoMessage()               {}
func (*GetGroupReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{50} }

type GetGroupResp struct {
	Group *Group `protobuf:"bytes,1,opt,name=group" json:"group"`
}

func (m *GetGroupResp) Reset()                    { *m = GetGroupResp{} }
func (m *GetGroupResp) String() string            { return proto.CompactTextString(m) }
func (*GetGroupResp) ProtoMessage()               {}
func (*GetGroupResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{51} }

func (m *GetGroupResp) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type DeleteGroupReq struct {
	ID    string `protobuf:"bytes,1,opt,name=group_id,json=groupId,proto3" json:"id"`
	AppID string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"appID"`
}

func (m *DeleteGroupReq) Reset()                    { *m = DeleteGroupReq{} }
func (m *DeleteGroupReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteGroupReq) ProtoMessage()               {}
func (*DeleteGroupReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{52} }

type DeleteGroupResp struct {
}

func (m *DeleteGroupResp) Reset()                    { *m = DeleteGroupResp{} }
func (m *DeleteGroupResp) String() string            { return proto.CompactTextString(m) }
func (*DeleteGroupResp) ProtoMessage()               {}
func (*DeleteGroupResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{53} }

type SetGroupChannelIDReq struct {
	ID        string `protobuf:"bytes,1,opt,name=group_id,json=groupId,proto3" json:"id"`
	AppID     string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"appID"`
	ChannelID string `protobuf:"bytes,3,opt,name=channel_id,json=channelId,proto3" json:"channelID"`
}

func (m *SetGroupChannelIDReq) Reset()                    { *m = SetGroupChannelIDReq{} }
func (m *SetGroupChannelIDReq) String() string            { return proto.CompactTextString(m) }
func (*SetGroupChannelIDReq) ProtoMessage()               {}
func (*SetGroupChannelIDReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{54} }

type SetGroupChannelIDResp struct {
	Group *Group `protobuf:"bytes,1,opt,name=group" json:"group"`
}

func (m *SetGroupChannelIDResp) Reset()                    { *m = SetGroupChannelIDResp{} }
func (m *SetGroupChannelIDResp) String() string            { return proto.CompactTextString(m) }
func (*SetGroupChannelIDResp) ProtoMessage()               {}
func (*SetGroupChannelIDResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{55} }

func (m *SetGroupChannelIDResp) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type SetGroupLabelReq struct {
	ID    string `protobuf:"bytes,1,opt,name=group_id,json=groupId,proto3" json:"id"`
	AppID string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"appID"`
	Label string `protobuf:"bytes,3,opt,name=label,proto3" json:"label"`
}

func (m *SetGroupLabelReq) Reset()                    { *m = SetGroupLabelReq{} }
func (m *SetGroupLabelReq) String() string            { return proto.CompactTextString(m) }
func (*SetGroupLabelReq) ProtoMessage()               {}
func (*SetGroupLabelReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{56} }

type SetGroupLabelResp struct {
	Group *Group `protobuf:"bytes,1,opt,name=group" json:"group"`
}

func (m *SetGroupLabelResp) Reset()                    { *m = SetGroupLabelResp{} }
func (m *SetGroupLabelResp) String() string            { return proto.CompactTextString(m) }
func (*SetGroupLabelResp) ProtoMessage()               {}
func (*SetGroupLabelResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{57} }

func (m *SetGroupLabelResp) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type SetGroupUpdateCountReq struct {
	ID          string `protobuf:"bytes,1,opt,name=group_id,json=groupId,proto3" json:"id"`
	AppID       string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"appID"`
	UpdateCount int64  `protobuf:"varint,3,opt,name=update_count,json=updateCount,proto3" json:"updateCount"`
}

func (m *SetGroupUpdateCountReq) Reset()                    { *m = SetGroupUpdateCountReq{} }
func (m *SetGroupUpdateCountReq) String() string            { return proto.CompactTextString(m) }
func (*SetGroupUpdateCountReq) ProtoMessage()               {}
func (*SetGroupUpdateCountReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{58} }

type SetGroupUpdateCountResp struct {
	Group *Group `protobuf:"bytes,1,opt,name=group" json:"group"`
}

func (m *SetGroupUpdateCountResp) Reset()                    { *m = SetGroupUpdateCountResp{} }
func (m *SetGroupUpdateCountResp) String() string            { return proto.CompactTextString(m) }
func (*SetGroupUpdateCountResp) ProtoMessage()               {}
func (*SetGroupUpdateCountResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{59} }

func (m *SetGroupUpdateCountResp) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type SetGroupUpdateIntervalReq struct {
	ID             string `protobuf:"bytes,1,opt,name=group_id,json=groupId,proto3" json:"id"`
	AppID          string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"appID"`
	UpdateInterval int64  `protobuf:"varint,3,opt,name=update_interval,json=updateInterval,proto3" json:"updateInterval"`
}

func (m *SetGroupUpdateIntervalReq) Reset()                    { *m = SetGroupUpdateIntervalReq{} }
func (m *SetGroupUpdateIntervalReq) String() string            { return proto.CompactTextString(m) }
func (*SetGroupUpdateIntervalReq) ProtoMessage()               {}
func (*SetGroupUpdateIntervalReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{60} }

type SetGroupUpdateIntervalResp struct {
	Group *Group `protobuf:"bytes,1,opt,name=group" json:"group"`
}

func (m *SetGroupUpdateIntervalResp) Reset()                    { *m = SetGroupUpdateIntervalResp{} }
func (m *SetGroupUpdateIntervalResp) String() string            { return proto.CompactTextString(m) }
func (*SetGroupUpdateIntervalResp) ProtoMessage()               {}
func (*SetGroupUpdateIntervalResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{61} }

func (m *SetGroupUpdateIntervalResp) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type SetGroupUpdatesPausedStateReq struct {
	ID            string `protobuf:"bytes,1,opt,name=group_id,json=groupId,proto3" json:"id"`
	AppID         string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"appID"`
	UpdatesPaused bool   `protobuf:"varint,3,opt,name=updates_paused,json=updatesPaused,proto3" json:"updatesPaused"`
}

func (m *SetGroupUpdatesPausedStateReq) Reset()         { *m = SetGroupUpdatesPausedStateReq{} }
func (m *SetGroupUpdatesPausedStateReq) String() string { return proto.CompactTextString(m) }
func (*SetGroupUpdatesPausedStateReq) ProtoMessage()    {}
func (*SetGroupUpdatesPausedStateReq) Descriptor() ([]byte, []int) {
	return fileDescriptorApi, []int{62}
}

type SetGroupUpdatesPausedStateResp struct {
	Group *Group `protobuf:"bytes,1,opt,name=group" json:"group"`
}

func (m *SetGroupUpdatesPausedStateResp) Reset()         { *m = SetGroupUpdatesPausedStateResp{} }
func (m *SetGroupUpdatesPausedStateResp) String() string { return proto.CompactTextString(m) }
func (*SetGroupUpdatesPausedStateResp) ProtoMessage()    {}
func (*SetGroupUpdatesPausedStateResp) Descriptor() ([]byte, []int) {
	return fileDescriptorApi, []int{63}
}

func (m *SetGroupUpdatesPausedStateResp) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type SetGroupUpdatePoolingReq struct {
	ID            string `protobuf:"bytes,1,opt,name=group_id,json=groupId,proto3" json:"id"`
	AppID         string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"appID"`
	UpdatePooling bool   `protobuf:"varint,3,opt,name=update_pooling,json=updatePooling,proto3" json:"updatePooling"`
}

func (m *SetGroupUpdatePoolingReq) Reset()                    { *m = SetGroupUpdatePoolingReq{} }
func (m *SetGroupUpdatePoolingReq) String() string            { return proto.CompactTextString(m) }
func (*SetGroupUpdatePoolingReq) ProtoMessage()               {}
func (*SetGroupUpdatePoolingReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{64} }

type SetGroupUpdatePoolingResp struct {
	Group *Group `protobuf:"bytes,1,opt,name=group" json:"group"`
}

func (m *SetGroupUpdatePoolingResp) Reset()                    { *m = SetGroupUpdatePoolingResp{} }
func (m *SetGroupUpdatePoolingResp) String() string            { return proto.CompactTextString(m) }
func (*SetGroupUpdatePoolingResp) ProtoMessage()               {}
func (*SetGroupUpdatePoolingResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{65} }

func (m *SetGroupUpdatePoolingResp) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type SetGroupOEMBlacklistReq struct {
	ID           string `protobuf:"bytes,1,opt,name=group_id,json=groupId,proto3" json:"id"`
	AppID        string `protobuf:"bytes,2,opt,name=app_id,json=appId,proto3" json:"appID"`
	OEMBlacklist string `protobuf:"bytes,3,opt,name=oem_blacklist,json=oemBlacklist,proto3" json:"oemBlacklist"`
}

func (m *SetGroupOEMBlacklistReq) Reset()                    { *m = SetGroupOEMBlacklistReq{} }
func (m *SetGroupOEMBlacklistReq) String() string            { return proto.CompactTextString(m) }
func (*SetGroupOEMBlacklistReq) ProtoMessage()               {}
func (*SetGroupOEMBlacklistReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{66} }

type SetGroupOEMBlacklistResp struct {
	Group *Group `protobuf:"bytes,1,opt,name=group" json:"group"`
}

func (m *SetGroupOEMBlacklistResp) Reset()                    { *m = SetGroupOEMBlacklistResp{} }
func (m *SetGroupOEMBlacklistResp) String() string            { return proto.CompactTextString(m) }
func (*SetGroupOEMBlacklistResp) ProtoMessage()               {}
func (*SetGroupOEMBlacklistResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{67} }

func (m *SetGroupOEMBlacklistResp) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

type GroupRequestsValues struct {
	Timestamp int64 `protobuf:"varint,1,opt,name=timestamp,proto3" json:"timestamp"`
	Count     int64 `protobuf:"varint,2,opt,name=count,proto3" json:"count"`
}

func (m *GroupRequestsValues) Reset()                    { *m = GroupRequestsValues{} }
func (m *GroupRequestsValues) String() string            { return proto.CompactTextString(m) }
func (*GroupRequestsValues) ProtoMessage()               {}
func (*GroupRequestsValues) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{68} }

type GetGroupVersionsRollupReq struct {
	AppID      string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"appID"`
	GroupID    string `protobuf:"bytes,2,opt,name=group_id,json=groupId,proto3" json:"groupID"`
	DateStart  int64  `protobuf:"varint,3,opt,name=date_start,json=dateStart,proto3" json:"dateStart"`
	DateEnd    int64  `protobuf:"varint,4,opt,name=date_end,json=dateEnd,proto3" json:"dateEnd"`
	Resolution int64  `protobuf:"varint,5,opt,name=resolution,proto3" json:"resolution"`
	Versions   string `protobuf:"bytes,6,opt,name=versions,proto3" json:"versions"`
}

func (m *GetGroupVersionsRollupReq) Reset()                    { *m = GetGroupVersionsRollupReq{} }
func (m *GetGroupVersionsRollupReq) String() string            { return proto.CompactTextString(m) }
func (*GetGroupVersionsRollupReq) ProtoMessage()               {}
func (*GetGroupVersionsRollupReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{69} }

type GroupVersionsItem struct {
	Version string                 `protobuf:"bytes,1,opt,name=version,proto3" json:"version"`
	Values  []*GroupRequestsValues `protobuf:"bytes,4,rep,name=values" json:"values"`
}

func (m *GroupVersionsItem) Reset()                    { *m = GroupVersionsItem{} }
func (m *GroupVersionsItem) String() string            { return proto.CompactTextString(m) }
func (*GroupVersionsItem) ProtoMessage()               {}
func (*GroupVersionsItem) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{70} }

func (m *GroupVersionsItem) GetValues() []*GroupRequestsValues {
	if m != nil {
		return m.Values
	}
	return nil
}

type GetGroupVersionsRollupResp struct {
	Items []*GroupVersionsItem `protobuf:"bytes,1,rep,name=items" json:"items"`
}

func (m *GetGroupVersionsRollupResp) Reset()                    { *m = GetGroupVersionsRollupResp{} }
func (m *GetGroupVersionsRollupResp) String() string            { return proto.CompactTextString(m) }
func (*GetGroupVersionsRollupResp) ProtoMessage()               {}
func (*GetGroupVersionsRollupResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{71} }

func (m *GetGroupVersionsRollupResp) GetItems() []*GroupVersionsItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type GetGroupEventsRollupReq struct {
	AppID      string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"appID"`
	GroupID    string `protobuf:"bytes,2,opt,name=group_id,json=groupId,proto3" json:"groupID"`
	DateStart  int64  `protobuf:"varint,3,opt,name=date_start,json=dateStart,proto3" json:"dateStart"`
	DateEnd    int64  `protobuf:"varint,4,opt,name=date_end,json=dateEnd,proto3" json:"dateEnd"`
	Resolution int64  `protobuf:"varint,5,opt,name=resolution,proto3" json:"resolution"`
	Versions   string `protobuf:"bytes,6,opt,name=versions,proto3" json:"versions"`
}

func (m *GetGroupEventsRollupReq) Reset()                    { *m = GetGroupEventsRollupReq{} }
func (m *GetGroupEventsRollupReq) String() string            { return proto.CompactTextString(m) }
func (*GetGroupEventsRollupReq) ProtoMessage()               {}
func (*GetGroupEventsRollupReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{72} }

type GroupEventsItem struct {
	Version     string                 `protobuf:"bytes,1,opt,name=version,proto3" json:"version"`
	EventType   int64                  `protobuf:"varint,2,opt,name=event_type,json=eventType,proto3" json:"eventType"`
	EventResult int64                  `protobuf:"varint,3,opt,name=event_result,json=eventResult,proto3" json:"eventResult"`
	Values      []*GroupRequestsValues `protobuf:"bytes,4,rep,name=values" json:"values"`
}

func (m *GroupEventsItem) Reset()                    { *m = GroupEventsItem{} }
func (m *GroupEventsItem) String() string            { return proto.CompactTextString(m) }
func (*GroupEventsItem) ProtoMessage()               {}
func (*GroupEventsItem) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{73} }

func (m *GroupEventsItem) GetValues() []*GroupRequestsValues {
	if m != nil {
		return m.Values
	}
	return nil
}

type GetGroupEventsRollupResp struct {
	Items []*GroupEventsItem `protobuf:"bytes,1,rep,name=items" json:"items"`
}

func (m *GetGroupEventsRollupResp) Reset()                    { *m = GetGroupEventsRollupResp{} }
func (m *GetGroupEventsRollupResp) String() string            { return proto.CompactTextString(m) }
func (*GetGroupEventsRollupResp) ProtoMessage()               {}
func (*GetGroupEventsRollupResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{74} }

func (m *GetGroupEventsRollupResp) GetItems() []*GroupEventsItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type CreatePackageReq struct {
	AppID                string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"appID"`
	Version              string `protobuf:"bytes,2,opt,name=version,proto3" json:"version"`
	URL                  string `protobuf:"bytes,3,opt,name=url,proto3" json:"url"`
	Size_                string `protobuf:"bytes,4,opt,name=size,proto3" json:"size"`
	Sha1Sum              string `protobuf:"bytes,5,opt,name=sha1_sum,json=sha1Sum,proto3" json:"sha1Sum"`
	Sha256Sum            string `protobuf:"bytes,6,opt,name=sha256_sum,json=sha256Sum,proto3" json:"sha256Sum"`
	Required             bool   `protobuf:"varint,7,opt,name=required,proto3" json:"required"`
	MetadataSignatureRsa string `protobuf:"bytes,8,opt,name=metadata_signature_rsa,json=metadataSignatureRsa,proto3" json:"metadataSignatureRsa"`
	MetadataSize         string `protobuf:"bytes,9,opt,name=metadata_size,json=metadataSize,proto3" json:"metadataSize"`
	ReleaseNotes         string `protobuf:"bytes,10,opt,name=release_notes,json=releaseNotes,proto3" json:"releaseNotes"`
}

func (m *CreatePackageReq) Reset()                    { *m = CreatePackageReq{} }
func (m *CreatePackageReq) String() string            { return proto.CompactTextString(m) }
func (*CreatePackageReq) ProtoMessage()               {}
func (*CreatePackageReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{75} }

type CreatePackageResp struct {
	Package *Package `protobuf:"bytes,1,opt,name=package" json:"package"`
}

func (m *CreatePackageResp) Reset()                    { *m = CreatePackageResp{} }
func (m *CreatePackageResp) String() string            { return proto.CompactTextString(m) }
func (*CreatePackageResp) ProtoMessage()               {}
func (*CreatePackageResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{76} }

func (m *CreatePackageResp) GetPackage() *Package {
	if m != nil {
		return m.Package
	}
	return nil
}

type ListPackagesReq struct {
	AppID string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"appID"`
	Limit int64  `protobuf:"varint,2,opt,name=limit,proto3" json:"limit"`
	Skip  int64  `protobuf:"varint,3,opt,name=skip,proto3" json:"skip"`
}

func (m *ListPackagesReq) Reset()                    { *m = ListPackagesReq{} }
func (m *ListPackagesReq) String() string            { return proto.CompactTextString(m) }
func (*ListPackagesReq) ProtoMessage()               {}
func (*ListPackagesReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{77} }

type ListPackagesResp struct {
	Items []*Package `protobuf:"bytes,1,rep,name=items" json:"items"`
	Total int64      `protobuf:"varint,2,opt,name=total,proto3" json:"total"`
}

func (m *ListPackagesResp) Reset()                    { *m = ListPackagesResp{} }
func (m *ListPackagesResp) String() string            { return proto.CompactTextString(m) }
func (*ListPackagesResp) ProtoMessage()               {}
func (*ListPackagesResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{78} }

func (m *ListPackagesResp) GetItems() []*Package {
	if m != nil {
		return m.Items
	}
	return nil
}

type GetPackageReq struct {
	AppID   string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"appID"`
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version"`
}

func (m *GetPackageReq) Reset()                    { *m = GetPackageReq{} }
func (m *GetPackageReq) String() string            { return proto.CompactTextString(m) }
func (*GetPackageReq) ProtoMessage()               {}
func (*GetPackageReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{79} }

type GetPackageResp struct {
	Package *Package `protobuf:"bytes,1,opt,name=package" json:"package"`
}

func (m *GetPackageResp) Reset()                    { *m = GetPackageResp{} }
func (m *GetPackageResp) String() string            { return proto.CompactTextString(m) }
func (*GetPackageResp) ProtoMessage()               {}
func (*GetPackageResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{80} }

func (m *GetPackageResp) GetPackage() *Package {
	if m != nil {
		return m.Package
	}
	return nil
}

type DeletePackageReq struct {
	AppID   string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"appID"`
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version"`
}

func (m *DeletePackageReq) Reset()                    { *m = DeletePackageReq{} }
func (m *DeletePackageReq) String() string            { return proto.CompactTextString(m) }
func (*DeletePackageReq) ProtoMessage()               {}
func (*DeletePackageReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{81} }

type DeletePackageResp struct {
}

func (m *DeletePackageResp) Reset()                    { *m = DeletePackageResp{} }
func (m *DeletePackageResp) String() string            { return proto.CompactTextString(m) }
func (*DeletePackageResp) ProtoMessage()               {}
func (*DeletePackageResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{82} }

type CreateUpstreamReq struct {
	URL   string `protobuf:"bytes,1,opt,name=url,proto3" json:"url"`
	Label string `protobuf:"bytes,2,opt,name=label,proto3" json:"label"`
}

func (m *CreateUpstreamReq) Reset()                    { *m = CreateUpstreamReq{} }
func (m *CreateUpstreamReq) String() string            { return proto.CompactTextString(m) }
func (*CreateUpstreamReq) ProtoMessage()               {}
func (*CreateUpstreamReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{83} }

type CreateUpstreamResp struct {
	Upstream *Upstream `protobuf:"bytes,1,opt,name=upstream" json:"upstream"`
}

func (m *CreateUpstreamResp) Reset()                    { *m = CreateUpstreamResp{} }
func (m *CreateUpstreamResp) String() string            { return proto.CompactTextString(m) }
func (*CreateUpstreamResp) ProtoMessage()               {}
func (*CreateUpstreamResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{84} }

func (m *CreateUpstreamResp) GetUpstream() *Upstream {
	if m != nil {
		return m.Upstream
	}
	return nil
}

type ListUpstreamsReq struct {
}

func (m *ListUpstreamsReq) Reset()                    { *m = ListUpstreamsReq{} }
func (m *ListUpstreamsReq) String() string            { return proto.CompactTextString(m) }
func (*ListUpstreamsReq) ProtoMessage()               {}
func (*ListUpstreamsReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{85} }

type ListUpstreamsResp struct {
	Items []*Upstream `protobuf:"bytes,1,rep,name=items" json:"items"`
}

func (m *ListUpstreamsResp) Reset()                    { *m = ListUpstreamsResp{} }
func (m *ListUpstreamsResp) String() string            { return proto.CompactTextString(m) }
func (*ListUpstreamsResp) ProtoMessage()               {}
func (*ListUpstreamsResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{86} }

func (m *ListUpstreamsResp) GetItems() []*Upstream {
	if m != nil {
		return m.Items
	}
	return nil
}

type GetUpstreamReq struct {
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
}

func (m *GetUpstreamReq) Reset()                    { *m = GetUpstreamReq{} }
func (m *GetUpstreamReq) String() string            { return proto.CompactTextString(m) }
func (*GetUpstreamReq) ProtoMessage()               {}
func (*GetUpstreamReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{87} }

type GetUpstreamResp struct {
	Upstream *Upstream `protobuf:"bytes,1,opt,name=upstream" json:"upstream"`
}

func (m *GetUpstreamResp) Reset()                    { *m = GetUpstreamResp{} }
func (m *GetUpstreamResp) String() string            { return proto.CompactTextString(m) }
func (*GetUpstreamResp) ProtoMessage()               {}
func (*GetUpstreamResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{88} }

func (m *GetUpstreamResp) GetUpstream() *Upstream {
	if m != nil {
		return m.Upstream
	}
	return nil
}

type DeleteUpstreamReq struct {
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
}

func (m *DeleteUpstreamReq) Reset()                    { *m = DeleteUpstreamReq{} }
func (m *DeleteUpstreamReq) String() string            { return proto.CompactTextString(m) }
func (*DeleteUpstreamReq) ProtoMessage()               {}
func (*DeleteUpstreamReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{89} }

type DeleteUpstreamResp struct {
}

func (m *DeleteUpstreamResp) Reset()                    { *m = DeleteUpstreamResp{} }
func (m *DeleteUpstreamResp) String() string            { return proto.CompactTextString(m) }
func (*DeleteUpstreamResp) ProtoMessage()               {}
func (*DeleteUpstreamResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{90} }

type SyncUpstreamsReq struct {
}

func (m *SyncUpstreamsReq) Reset()                    { *m = SyncUpstreamsReq{} }
func (m *SyncUpstreamsReq) String() string            { return proto.CompactTextString(m) }
func (*SyncUpstreamsReq) ProtoMessage()               {}
func (*SyncUpstreamsReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{91} }

type SyncUpstreamsResp struct {
	Status string `protobuf:"bytes,1,opt,name=status,proto3" json:"status"`
	Detail string `protobuf:"bytes,2,opt,name=detail,proto3" json:"detail"`
}

func (m *SyncUpstreamsResp) Reset()                    { *m = SyncUpstreamsResp{} }
func (m *SyncUpstreamsResp) String() string            { return proto.CompactTextString(m) }
func (*SyncUpstreamsResp) ProtoMessage()               {}
func (*SyncUpstreamsResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{92} }

type SetUpstreamURLReq struct {
	ID  string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	URL string `protobuf:"bytes,2,opt,name=url,proto3" json:"url"`
}

func (m *SetUpstreamURLReq) Reset()                    { *m = SetUpstreamURLReq{} }
func (m *SetUpstreamURLReq) String() string            { return proto.CompactTextString(m) }
func (*SetUpstreamURLReq) ProtoMessage()               {}
func (*SetUpstreamURLReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{93} }

type SetUpstreamURLResp struct {
	Upstream *Upstream `protobuf:"bytes,1,opt,name=upstream" json:"upstream"`
}

func (m *SetUpstreamURLResp) Reset()                    { *m = SetUpstreamURLResp{} }
func (m *SetUpstreamURLResp) String() string            { return proto.CompactTextString(m) }
func (*SetUpstreamURLResp) ProtoMessage()               {}
func (*SetUpstreamURLResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{94} }

func (m *SetUpstreamURLResp) GetUpstream() *Upstream {
	if m != nil {
		return m.Upstream
	}
	return nil
}

type SetUpstreamLabelReq struct {
	ID    string `protobuf:"bytes,1,opt,name=id,proto3" json:"id"`
	Label string `protobuf:"bytes,2,opt,name=label,proto3" json:"label"`
}

func (m *SetUpstreamLabelReq) Reset()                    { *m = SetUpstreamLabelReq{} }
func (m *SetUpstreamLabelReq) String() string            { return proto.CompactTextString(m) }
func (*SetUpstreamLabelReq) ProtoMessage()               {}
func (*SetUpstreamLabelReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{95} }

type SetUpstreamLabelResp struct {
	Upstream *Upstream `protobuf:"bytes,1,opt,name=upstream" json:"upstream"`
}

func (m *SetUpstreamLabelResp) Reset()                    { *m = SetUpstreamLabelResp{} }
func (m *SetUpstreamLabelResp) String() string            { return proto.CompactTextString(m) }
func (*SetUpstreamLabelResp) ProtoMessage()               {}
func (*SetUpstreamLabelResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{96} }

func (m *SetUpstreamLabelResp) GetUpstream() *Upstream {
	if m != nil {
		return m.Upstream
	}
	return nil
}

type GetClientHistoryReq struct {
	ClientID string `protobuf:"bytes,1,opt,name=client_id,json=clientId,proto3" json:"clientID"`
}

func (m *GetClientHistoryReq) Reset()                    { *m = GetClientHistoryReq{} }
func (m *GetClientHistoryReq) String() string            { return proto.CompactTextString(m) }
func (*GetClientHistoryReq) ProtoMessage()               {}
func (*GetClientHistoryReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{97} }

type GetClientHistoryItem struct {
	DateTime      int64  `protobuf:"varint,1,opt,name=date_time,json=dateTime,proto3" json:"dateTime"`
	EventType     int64  `protobuf:"varint,2,opt,name=event_type,json=eventType,proto3" json:"eventType"`
	EventResult   int64  `protobuf:"varint,3,opt,name=event_result,json=eventResult,proto3" json:"eventResult"`
	ErrorCode     int64  `protobuf:"varint,4,opt,name=error_code,json=errorCode,proto3" json:"errorCode"`
	Version       string `protobuf:"bytes,5,opt,name=version,proto3" json:"version"`
	GroupID       string `protobuf:"bytes,6,opt,name=group_id,json=groupId,proto3" json:"groupID"`
	InstallSource string `protobuf:"bytes,7,opt,name=install_source,json=installSource,proto3" json:"installSource"`
}

func (m *GetClientHistoryItem) Reset()                    { *m = GetClientHistoryItem{} }
func (m *GetClientHistoryItem) String() string            { return proto.CompactTextString(m) }
func (*GetClientHistoryItem) ProtoMessage()               {}
func (*GetClientHistoryItem) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{98} }

type GetClientHistoryResp struct {
	Items []*GetClientHistoryItem `protobuf:"bytes,1,rep,name=items" json:"items"`
}

func (m *GetClientHistoryResp) Reset()                    { *m = GetClientHistoryResp{} }
func (m *GetClientHistoryResp) String() string            { return proto.CompactTextString(m) }
func (*GetClientHistoryResp) ProtoMessage()               {}
func (*GetClientHistoryResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{99} }

func (m *GetClientHistoryResp) GetItems() []*GetClientHistoryItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type ListAppVersionsReq struct {
	DateStart   int64  `protobuf:"varint,1,opt,name=date_start,json=dateStart,proto3" json:"dateStart"`
	DateEnd     int64  `protobuf:"varint,2,opt,name=date_end,json=dateEnd,proto3" json:"dateEnd"`
	AppID       string `protobuf:"bytes,3,opt,name=app_id,json=appId,proto3" json:"appID"`
	GroupID     string `protobuf:"bytes,4,opt,name=group_id,json=groupId,proto3" json:"groupID"`
	Version     string `protobuf:"bytes,5,opt,name=version,proto3" json:"version"`
	OEM         string `protobuf:"bytes,6,opt,name=oem,proto3" json:"oem"`
	EventType   int64  `protobuf:"varint,7,opt,name=event_type,json=eventType,proto3" json:"eventType"`
	EventResult int64  `protobuf:"varint,8,opt,name=event_result,json=eventResult,proto3" json:"eventResult"`
}

func (m *ListAppVersionsReq) Reset()                    { *m = ListAppVersionsReq{} }
func (m *ListAppVersionsReq) String() string            { return proto.CompactTextString(m) }
func (*ListAppVersionsReq) ProtoMessage()               {}
func (*ListAppVersionsReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{100} }

type AppVersionItem struct {
	AppID   string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"appID"`
	GroupID string `protobuf:"bytes,2,opt,name=group_id,json=groupId,proto3" json:"groupID"`
	Version string `protobuf:"bytes,3,opt,name=version,proto3" json:"version"`
	Count   string `protobuf:"bytes,4,opt,name=count,proto3" json:"count"`
}

func (m *AppVersionItem) Reset()                    { *m = AppVersionItem{} }
func (m *AppVersionItem) String() string            { return proto.CompactTextString(m) }
func (*AppVersionItem) ProtoMessage()               {}
func (*AppVersionItem) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{101} }

type ListAppVersionsResp struct {
	Items []*AppVersionItem `protobuf:"bytes,1,rep,name=items" json:"items"`
}

func (m *ListAppVersionsResp) Reset()                    { *m = ListAppVersionsResp{} }
func (m *ListAppVersionsResp) String() string            { return proto.CompactTextString(m) }
func (*ListAppVersionsResp) ProtoMessage()               {}
func (*ListAppVersionsResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{102} }

func (m *ListAppVersionsResp) GetItems() []*AppVersionItem {
	if m != nil {
		return m.Items
	}
	return nil
}

type ListClientUpdatesReq struct {
	DateStart   int64  `protobuf:"varint,1,opt,name=date_start,json=dateStart,proto3" json:"dateStart"`
	DateEnd     int64  `protobuf:"varint,2,opt,name=date_end,json=dateEnd,proto3" json:"dateEnd"`
	AppID       string `protobuf:"bytes,3,opt,name=app_id,json=appId,proto3" json:"appID"`
	GroupID     string `protobuf:"bytes,4,opt,name=group_id,json=groupId,proto3" json:"groupID"`
	Version     string `protobuf:"bytes,5,opt,name=version,proto3" json:"version"`
	OEM         string `protobuf:"bytes,6,opt,name=oem,proto3" json:"oem"`
	EventType   int64  `protobuf:"varint,7,opt,name=event_type,json=eventType,proto3" json:"eventType"`
	EventResult int64  `protobuf:"varint,8,opt,name=event_result,json=eventResult,proto3" json:"eventResult"`
	ClientID    string `protobuf:"bytes,9,opt,name=client_id,json=clientId,proto3" json:"clientID"`
	Limit       int64  `protobuf:"varint,10,opt,name=limit,proto3" json:"limit"`
	Skip        int64  `protobuf:"varint,11,opt,name=skip,proto3" json:"skip"`
}

func (m *ListClientUpdatesReq) Reset()                    { *m = ListClientUpdatesReq{} }
func (m *ListClientUpdatesReq) String() string            { return proto.CompactTextString(m) }
func (*ListClientUpdatesReq) ProtoMessage()               {}
func (*ListClientUpdatesReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{103} }

type ClientUpdate struct {
	AppID       string `protobuf:"bytes,1,opt,name=app_id,json=appId,proto3" json:"appID"`
	ClientID    string `protobuf:"bytes,2,opt,name=client_id,json=clientId,proto3" json:"clientID"`
	GroupID     string `protobuf:"bytes,3,opt,name=group_id,json=groupId,proto3" json:"groupID"`
	Version     string `protobuf:"bytes,4,opt,name=version,proto3" json:"version"`
	LastSeen    string `protobuf:"bytes,5,opt,name=last_seen,json=lastSeen,proto3" json:"lastSeen"`
	EventType   int64  `protobuf:"varint,6,opt,name=event_type,json=eventType,proto3" json:"eventType"`
	EventResult int64  `protobuf:"varint,7,opt,name=event_result,json=eventResult,proto3" json:"eventResult"`
	ErrorCode   int64  `protobuf:"varint,8,opt,name=error_code,json=errorCode,proto3" json:"errorCode"`
	OEM         string `protobuf:"bytes,9,opt,name=oem,proto3" json:"oem"`
}

func (m *ClientUpdate) Reset()                    { *m = ClientUpdate{} }
func (m *ClientUpdate) String() string            { return proto.CompactTextString(m) }
func (*ClientUpdate) ProtoMessage()               {}
func (*ClientUpdate) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{104} }

type ListClientUpdatesResp struct {
	Items []*ClientUpdate `protobuf:"bytes,1,rep,name=items" json:"items"`
}

func (m *ListClientUpdatesResp) Reset()                    { *m = ListClientUpdatesResp{} }
func (m *ListClientUpdatesResp) String() string            { return proto.CompactTextString(m) }
func (*ListClientUpdatesResp) ProtoMessage()               {}
func (*ListClientUpdatesResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{105} }

func (m *ListClientUpdatesResp) GetItems() []*ClientUpdate {
	if m != nil {
		return m.Items
	}
	return nil
}

type GetClientUpdateCountReq struct {
	DateStart   int64  `protobuf:"varint,1,opt,name=date_start,json=dateStart,proto3" json:"dateStart"`
	DateEnd     int64  `protobuf:"varint,2,opt,name=date_end,json=dateEnd,proto3" json:"dateEnd"`
	AppID       string `protobuf:"bytes,3,opt,name=app_id,json=appId,proto3" json:"appID"`
	GroupID     string `protobuf:"bytes,4,opt,name=group_id,json=groupId,proto3" json:"groupID"`
	Version     string `protobuf:"bytes,5,opt,name=version,proto3" json:"version"`
	OEM         string `protobuf:"bytes,6,opt,name=oem,proto3" json:"oem"`
	EventType   int64  `protobuf:"varint,7,opt,name=event_type,json=eventType,proto3" json:"eventType"`
	EventResult int64  `protobuf:"varint,8,opt,name=event_result,json=eventResult,proto3" json:"eventResult"`
}

func (m *GetClientUpdateCountReq) Reset()                    { *m = GetClientUpdateCountReq{} }
func (m *GetClientUpdateCountReq) String() string            { return proto.CompactTextString(m) }
func (*GetClientUpdateCountReq) ProtoMessage()               {}
func (*GetClientUpdateCountReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{106} }

type GetClientUpdateCountResp struct {
	Count int64 `protobuf:"varint,1,opt,name=count,proto3" json:"count"`
}

func (m *GetClientUpdateCountResp) Reset()                    { *m = GetClientUpdateCountResp{} }
func (m *GetClientUpdateCountResp) String() string            { return proto.CompactTextString(m) }
func (*GetClientUpdateCountResp) ProtoMessage()               {}
func (*GetClientUpdateCountResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{107} }

type GenerateUUIDReq struct {
}

func (m *GenerateUUIDReq) Reset()                    { *m = GenerateUUIDReq{} }
func (m *GenerateUUIDReq) String() string            { return proto.CompactTextString(m) }
func (*GenerateUUIDReq) ProtoMessage()               {}
func (*GenerateUUIDReq) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{108} }

type GenerateUUIDResp struct {
	UUID string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid"`
}

func (m *GenerateUUIDResp) Reset()                    { *m = GenerateUUIDResp{} }
func (m *GenerateUUIDResp) String() string            { return proto.CompactTextString(m) }
func (*GenerateUUIDResp) ProtoMessage()               {}
func (*GenerateUUIDResp) Descriptor() ([]byte, []int) { return fileDescriptorApi, []int{109} }

func init() {
	proto.RegisterType((*User)(nil), "update.User")
	proto.RegisterType((*App)(nil), "update.App")
	proto.RegisterType((*Channel)(nil), "update.Channel")
	proto.RegisterType((*Group)(nil), "update.Group")
	proto.RegisterType((*Package)(nil), "update.Package")
	proto.RegisterType((*Upstream)(nil), "update.Upstream")
	proto.RegisterType((*CreateUserReq)(nil), "update.CreateUserReq")
	proto.RegisterType((*CreateUserResp)(nil), "update.CreateUserResp")
	proto.RegisterType((*ListUsersReq)(nil), "update.ListUsersReq")
	proto.RegisterType((*ListUsersResp)(nil), "update.ListUsersResp")
	proto.RegisterType((*GetUserReq)(nil), "update.GetUserReq")
	proto.RegisterType((*GetUserResp)(nil), "update.GetUserResp")
	proto.RegisterType((*DeleteUserReq)(nil), "update.DeleteUserReq")
	proto.RegisterType((*DeleteUserResp)(nil), "update.DeleteUserResp")
	proto.RegisterType((*GenerateUserTokenReq)(nil), "update.GenerateUserTokenReq")
	proto.RegisterType((*GenerateUserTokenResp)(nil), "update.GenerateUserTokenResp")
	proto.RegisterType((*CreateAppReq)(nil), "update.CreateAppReq")
	proto.RegisterType((*CreateAppResp)(nil), "update.CreateAppResp")
	proto.RegisterType((*ListAppsReq)(nil), "update.ListAppsReq")
	proto.RegisterType((*ListAppsResp)(nil), "update.ListAppsResp")
	proto.RegisterType((*GetAppReq)(nil), "update.GetAppReq")
	proto.RegisterType((*GetAppResp)(nil), "update.GetAppResp")
	proto.RegisterType((*DeleteAppReq)(nil), "update.DeleteAppReq")
	proto.RegisterType((*DeleteAppResp)(nil), "update.DeleteAppResp")
	proto.RegisterType((*SetAppLabelReq)(nil), "update.SetAppLabelReq")
	proto.RegisterType((*SetAppLabelResp)(nil), "update.SetAppLabelResp")
	proto.RegisterType((*SetAppDescriptionReq)(nil), "update.SetAppDescriptionReq")
	proto.RegisterType((*SetAppDescriptionResp)(nil), "update.SetAppDescriptionResp")
	proto.RegisterType((*CreateChannelReq)(nil), "update.CreateChannelReq")
	proto.RegisterType((*CreateChannelResp)(nil), "update.CreateChannelResp")
	proto.RegisterType((*ListChannelsReq)(nil), "update.ListChannelsReq")
	proto.RegisterType((*ListChannelsResp)(nil), "update.ListChannelsResp")
	proto.RegisterType((*GetChannelReq)(nil), "update.GetChannelReq")
	proto.RegisterType((*GetChannelResp)(nil), "update.GetChannelResp")
	proto.RegisterType((*DeleteChannelReq)(nil), "update.DeleteChannelReq")
	proto.RegisterType((*DeleteChannelResp)(nil), "update.DeleteChannelResp")
	proto.RegisterType((*SetChannelLabelReq)(nil), "update.SetChannelLabelReq")
	proto.RegisterType((*SetChannelLabelResp)(nil), "update.SetChannelLabelResp")
	proto.RegisterType((*SetChannelVersionReq)(nil), "update.SetChannelVersionReq")
	proto.RegisterType((*SetChannelVersionResp)(nil), "update.SetChannelVersionResp")
	proto.RegisterType((*SetChannelPublishReq)(nil), "update.SetChannelPublishReq")
	proto.RegisterType((*SetChannelPublishResp)(nil), "update.SetChannelPublishResp")
	proto.RegisterType((*SetChannelUpstreamReq)(nil), "update.SetChannelUpstreamReq")
	proto.RegisterType((*SetChannelUpstreamResp)(nil), "update.SetChannelUpstreamResp")
	proto.RegisterType((*DeleteChannelUpstreamReq)(nil), "update.DeleteChannelUpstreamReq")
	proto.RegisterType((*DeleteChannelUpstreamResp)(nil), "update.DeleteChannelUpstreamResp")
	proto.RegisterType((*CreateGroupReq)(nil), "update.CreateGroupReq")
	proto.RegisterType((*CreateGroupResp)(nil), "update.CreateGroupResp")
	proto.RegisterType((*ListGroupsReq)(nil), "update.ListGroupsReq")
	proto.RegisterType((*ListGroupsResp)(nil), "update.ListGroupsResp")
	proto.RegisterType((*GetGroupReq)(nil), "update.GetGroupReq")
	proto.RegisterType((*GetGroupResp)(nil), "update.GetGroupResp")
	proto.RegisterType((*DeleteGroupReq)(nil), "update.DeleteGroupReq")
	proto.RegisterType((*DeleteGroupResp)(nil), "update.DeleteGroupResp")
	proto.RegisterType((*SetGroupChannelIDReq)(nil), "update.SetGroupChannelIDReq")
	proto.RegisterType((*SetGroupChannelIDResp)(nil), "update.SetGroupChannelIDResp")
	proto.RegisterType((*SetGroupLabelReq)(nil), "update.SetGroupLabelReq")
	proto.RegisterType((*SetGroupLabelResp)(nil), "update.SetGroupLabelResp")
	proto.RegisterType((*SetGroupUpdateCountReq)(nil), "update.SetGroupUpdateCountReq")
	proto.RegisterType((*SetGroupUpdateCountResp)(nil), "update.SetGroupUpdateCountResp")
	proto.RegisterType((*SetGroupUpdateIntervalReq)(nil), "update.SetGroupUpdateIntervalReq")
	proto.RegisterType((*SetGroupUpdateIntervalResp)(nil), "update.SetGroupUpdateIntervalResp")
	proto.RegisterType((*SetGroupUpdatesPausedStateReq)(nil), "update.SetGroupUpdatesPausedStateReq")
	proto.RegisterType((*SetGroupUpdatesPausedStateResp)(nil), "update.SetGroupUpdatesPausedStateResp")
	proto.RegisterType((*SetGroupUpdatePoolingReq)(nil), "update.SetGroupUpdatePoolingReq")
	proto.RegisterType((*SetGroupUpdatePoolingResp)(nil), "update.SetGroupUpdatePoolingResp")
	proto.RegisterType((*SetGroupOEMBlacklistReq)(nil), "update.SetGroupOEMBlacklistReq")
	proto.RegisterType((*SetGroupOEMBlacklistResp)(nil), "update.SetGroupOEMBlacklistResp")
	proto.RegisterType((*GroupRequestsValues)(nil), "update.GroupRequestsValues")
	proto.RegisterType((*GetGroupVersionsRollupReq)(nil), "update.GetGroupVersionsRollupReq")
	proto.RegisterType((*GroupVersionsItem)(nil), "update.GroupVersionsItem")
	proto.RegisterType((*GetGroupVersionsRollupResp)(nil), "update.GetGroupVersionsRollupResp")
	proto.RegisterType((*GetGroupEventsRollupReq)(nil), "update.GetGroupEventsRollupReq")
	proto.RegisterType((*GroupEventsItem)(nil), "update.GroupEventsItem")
	proto.RegisterType((*GetGroupEventsRollupResp)(nil), "update.GetGroupEventsRollupResp")
	proto.RegisterType((*CreatePackageReq)(nil), "update.CreatePackageReq")
	proto.RegisterType((*CreatePackageResp)(nil), "update.CreatePackageResp")
	proto.RegisterType((*ListPackagesReq)(nil), "update.ListPackagesReq")
	proto.RegisterType((*ListPackagesResp)(nil), "update.ListPackagesResp")
	proto.RegisterType((*GetPackageReq)(nil), "update.GetPackageReq")
	proto.RegisterType((*GetPackageResp)(nil), "update.GetPackageResp")
	proto.RegisterType((*DeletePackageReq)(nil), "update.DeletePackageReq")
	proto.RegisterType((*DeletePackageResp)(nil), "update.DeletePackageResp")
	proto.RegisterType((*CreateUpstreamReq)(nil), "update.CreateUpstreamReq")
	proto.RegisterType((*CreateUpstreamResp)(nil), "update.CreateUpstreamResp")
	proto.RegisterType((*ListUpstreamsReq)(nil), "update.ListUpstreamsReq")
	proto.RegisterType((*ListUpstreamsResp)(nil), "update.ListUpstreamsResp")
	proto.RegisterType((*GetUpstreamReq)(nil), "update.GetUpstreamReq")
	proto.RegisterType((*GetUpstreamResp)(nil), "update.GetUpstreamResp")
	proto.RegisterType((*DeleteUpstreamReq)(nil), "update.DeleteUpstreamReq")
	proto.RegisterType((*DeleteUpstreamResp)(nil), "update.DeleteUpstreamResp")
	proto.RegisterType((*SyncUpstreamsReq)(nil), "update.SyncUpstreamsReq")
	proto.RegisterType((*SyncUpstreamsResp)(nil), "update.SyncUpstreamsResp")
	proto.RegisterType((*SetUpstreamURLReq)(nil), "update.SetUpstreamURLReq")
	proto.RegisterType((*SetUpstreamURLResp)(nil), "update.SetUpstreamURLResp")
	proto.RegisterType((*SetUpstreamLabelReq)(nil), "update.SetUpstreamLabelReq")
	proto.RegisterType((*SetUpstreamLabelResp)(nil), "update.SetUpstreamLabelResp")
	proto.RegisterType((*GetClientHistoryReq)(nil), "update.GetClientHistoryReq")
	proto.RegisterType((*GetClientHistoryItem)(nil), "update.GetClientHistoryItem")
	proto.RegisterType((*GetClientHistoryResp)(nil), "update.GetClientHistoryResp")
	proto.RegisterType((*ListAppVersionsReq)(nil), "update.ListAppVersionsReq")
	proto.RegisterType((*AppVersionItem)(nil), "update.AppVersionItem")
	proto.RegisterType((*ListAppVersionsResp)(nil), "update.ListAppVersionsResp")
	proto.RegisterType((*ListClientUpdatesReq)(nil), "update.ListClientUpdatesReq")
	proto.RegisterType((*ClientUpdate)(nil), "update.ClientUpdate")
	proto.RegisterType((*ListClientUpdatesResp)(nil), "update.ListClientUpdatesResp")
	proto.RegisterType((*GetClientUpdateCountReq)(nil), "update.GetClientUpdateCountReq")
	proto.RegisterType((*GetClientUpdateCountResp)(nil), "update.GetClientUpdateCountResp")
	proto.RegisterType((*GenerateUUIDReq)(nil), "update.GenerateUUIDReq")
	proto.RegisterType((*GenerateUUIDResp)(nil), "update.GenerateUUIDResp")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for UpdateService service

type UpdateServiceClient interface {
	// users
	CreateUser(ctx context.Context, in *CreateUserReq, opts ...grpc.CallOption) (*CreateUserResp, error)
	ListUsers(ctx context.Context, in *ListUsersReq, opts ...grpc.CallOption) (*ListUsersResp, error)
	GetUser(ctx context.Context, in *GetUserReq, opts ...grpc.CallOption) (*GetUserResp, error)
	DeleteUser(ctx context.Context, in *DeleteUserReq, opts ...grpc.CallOption) (*DeleteUserResp, error)
	GenerateUserToken(ctx context.Context, in *GenerateUserTokenReq, opts ...grpc.CallOption) (*GenerateUserTokenResp, error)
	// applications
	CreateApp(ctx context.Context, in *CreateAppReq, opts ...grpc.CallOption) (*CreateAppResp, error)
	ListApps(ctx context.Context, in *ListAppsReq, opts ...grpc.CallOption) (*ListAppsResp, error)
	GetApp(ctx context.Context, in *GetAppReq, opts ...grpc.CallOption) (*GetAppResp, error)
	DeleteApp(ctx context.Context, in *DeleteAppReq, opts ...grpc.CallOption) (*DeleteAppResp, error)
	SetAppLabel(ctx context.Context, in *SetAppLabelReq, opts ...grpc.CallOption) (*SetAppLabelResp, error)
	SetAppDescription(ctx context.Context, in *SetAppDescriptionReq, opts ...grpc.CallOption) (*SetAppDescriptionResp, error)
	// channels
	CreateChannel(ctx context.Context, in *CreateChannelReq, opts ...grpc.CallOption) (*CreateChannelResp, error)
	ListChannels(ctx context.Context, in *ListChannelsReq, opts ...grpc.CallOption) (*ListChannelsResp, error)
	GetChannel(ctx context.Context, in *GetChannelReq, opts ...grpc.CallOption) (*GetChannelResp, error)
	DeleteChannel(ctx context.Context, in *DeleteChannelReq, opts ...grpc.CallOption) (*DeleteChannelResp, error)
	SetChannelLabel(ctx context.Context, in *SetChannelLabelReq, opts ...grpc.CallOption) (*SetChannelLabelResp, error)
	SetChannelVersion(ctx context.Context, in *SetChannelVersionReq, opts ...grpc.CallOption) (*SetChannelVersionResp, error)
	SetChannelPublished(ctx context.Context, in *SetChannelPublishReq, opts ...grpc.CallOption) (*SetChannelPublishResp, error)
	SetChannelUpstream(ctx context.Context, in *SetChannelUpstreamReq, opts ...grpc.CallOption) (*SetChannelUpstreamResp, error)
	DeleteChannelUpstream(ctx context.Context, in *DeleteChannelUpstreamReq, opts ...grpc.CallOption) (*DeleteChannelUpstreamResp, error)
	// groups
	CreateGroup(ctx context.Context, in *CreateGroupReq, opts ...grpc.CallOption) (*CreateGroupResp, error)
	ListGroups(ctx context.Context, in *ListGroupsReq, opts ...grpc.CallOption) (*ListGroupsResp, error)
	GetGroup(ctx context.Context, in *GetGroupReq, opts ...grpc.CallOption) (*GetGroupResp, error)
	DeleteGroup(ctx context.Context, in *DeleteGroupReq, opts ...grpc.CallOption) (*DeleteGroupResp, error)
	SetGroupChannelID(ctx context.Context, in *SetGroupChannelIDReq, opts ...grpc.CallOption) (*SetGroupChannelIDResp, error)
	SetGroupLabel(ctx context.Context, in *SetGroupLabelReq, opts ...grpc.CallOption) (*SetGroupLabelResp, error)
	SetGroupUpdateCount(ctx context.Context, in *SetGroupUpdateCountReq, opts ...grpc.CallOption) (*SetGroupUpdateCountResp, error)
	SetGroupUpdateInterval(ctx context.Context, in *SetGroupUpdateIntervalReq, opts ...grpc.CallOption) (*SetGroupUpdateIntervalResp, error)
	SetGroupUpdatesPausedState(ctx context.Context, in *SetGroupUpdatesPausedStateReq, opts ...grpc.CallOption) (*SetGroupUpdatesPausedStateResp, error)
	SetGroupUpdatePooling(ctx context.Context, in *SetGroupUpdatePoolingReq, opts ...grpc.CallOption) (*SetGroupUpdatePoolingResp, error)
	SetGroupOEMBlacklist(ctx context.Context, in *SetGroupOEMBlacklistReq, opts ...grpc.CallOption) (*SetGroupOEMBlacklistResp, error)
	// rollup functions
	GetGroupVersionsRollup(ctx context.Context, in *GetGroupVersionsRollupReq, opts ...grpc.CallOption) (*GetGroupVersionsRollupResp, error)
	GetGroupEventsRollup(ctx context.Context, in *GetGroupEventsRollupReq, opts ...grpc.CallOption) (*GetGroupEventsRollupResp, error)
	// packages
	CreatePackage(ctx context.Context, in *CreatePackageReq, opts ...grpc.CallOption) (*CreatePackageResp, error)
	ListPackages(ctx context.Context, in *ListPackagesReq, opts ...grpc.CallOption) (*ListPackagesResp, error)
	GetPackage(ctx context.Context, in *GetPackageReq, opts ...grpc.CallOption) (*GetPackageResp, error)
	DeletePackage(ctx context.Context, in *DeletePackageReq, opts ...grpc.CallOption) (*DeletePackageResp, error)
	// upstreams
	CreateUpstream(ctx context.Context, in *CreateUpstreamReq, opts ...grpc.CallOption) (*CreateUpstreamResp, error)
	ListUpstreams(ctx context.Context, in *ListUpstreamsReq, opts ...grpc.CallOption) (*ListUpstreamsResp, error)
	GetUpstream(ctx context.Context, in *GetUpstreamReq, opts ...grpc.CallOption) (*GetUpstreamResp, error)
	DeleteUpstream(ctx context.Context, in *DeleteUpstreamReq, opts ...grpc.CallOption) (*DeleteUpstreamResp, error)
	SyncUpstreams(ctx context.Context, in *SyncUpstreamsReq, opts ...grpc.CallOption) (*SyncUpstreamsResp, error)
	SetUpstreamURL(ctx context.Context, in *SetUpstreamURLReq, opts ...grpc.CallOption) (*SetUpstreamURLResp, error)
	SetUpstreamLabel(ctx context.Context, in *SetUpstreamLabelReq, opts ...grpc.CallOption) (*SetUpstreamLabelResp, error)
	// client requests
	GetClientHistory(ctx context.Context, in *GetClientHistoryReq, opts ...grpc.CallOption) (*GetClientHistoryResp, error)
	// client updates
	ListAppVersions(ctx context.Context, in *ListAppVersionsReq, opts ...grpc.CallOption) (*ListAppVersionsResp, error)
	ListClientUpdates(ctx context.Context, in *ListClientUpdatesReq, opts ...grpc.CallOption) (*ListClientUpdatesResp, error)
	GetClientUpdateCount(ctx context.Context, in *GetClientUpdateCountReq, opts ...grpc.CallOption) (*GetClientUpdateCountResp, error)
	// utility functions
	GenerateUUID(ctx context.Context, in *GenerateUUIDReq, opts ...grpc.CallOption) (*GenerateUUIDResp, error)
}

type updateServiceClient struct {
	cc *grpc.ClientConn
}

func NewUpdateServiceClient(cc *grpc.ClientConn) UpdateServiceClient {
	return &updateServiceClient{cc}
}

func (c *updateServiceClient) CreateUser(ctx context.Context, in *CreateUserReq, opts ...grpc.CallOption) (*CreateUserResp, error) {
	out := new(CreateUserResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/CreateUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) ListUsers(ctx context.Context, in *ListUsersReq, opts ...grpc.CallOption) (*ListUsersResp, error) {
	out := new(ListUsersResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/ListUsers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) GetUser(ctx context.Context, in *GetUserReq, opts ...grpc.CallOption) (*GetUserResp, error) {
	out := new(GetUserResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/GetUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) DeleteUser(ctx context.Context, in *DeleteUserReq, opts ...grpc.CallOption) (*DeleteUserResp, error) {
	out := new(DeleteUserResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/DeleteUser", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) GenerateUserToken(ctx context.Context, in *GenerateUserTokenReq, opts ...grpc.CallOption) (*GenerateUserTokenResp, error) {
	out := new(GenerateUserTokenResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/GenerateUserToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) CreateApp(ctx context.Context, in *CreateAppReq, opts ...grpc.CallOption) (*CreateAppResp, error) {
	out := new(CreateAppResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/CreateApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) ListApps(ctx context.Context, in *ListAppsReq, opts ...grpc.CallOption) (*ListAppsResp, error) {
	out := new(ListAppsResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/ListApps", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) GetApp(ctx context.Context, in *GetAppReq, opts ...grpc.CallOption) (*GetAppResp, error) {
	out := new(GetAppResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/GetApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) DeleteApp(ctx context.Context, in *DeleteAppReq, opts ...grpc.CallOption) (*DeleteAppResp, error) {
	out := new(DeleteAppResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/DeleteApp", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetAppLabel(ctx context.Context, in *SetAppLabelReq, opts ...grpc.CallOption) (*SetAppLabelResp, error) {
	out := new(SetAppLabelResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SetAppLabel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetAppDescription(ctx context.Context, in *SetAppDescriptionReq, opts ...grpc.CallOption) (*SetAppDescriptionResp, error) {
	out := new(SetAppDescriptionResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SetAppDescription", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) CreateChannel(ctx context.Context, in *CreateChannelReq, opts ...grpc.CallOption) (*CreateChannelResp, error) {
	out := new(CreateChannelResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/CreateChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) ListChannels(ctx context.Context, in *ListChannelsReq, opts ...grpc.CallOption) (*ListChannelsResp, error) {
	out := new(ListChannelsResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/ListChannels", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) GetChannel(ctx context.Context, in *GetChannelReq, opts ...grpc.CallOption) (*GetChannelResp, error) {
	out := new(GetChannelResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/GetChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) DeleteChannel(ctx context.Context, in *DeleteChannelReq, opts ...grpc.CallOption) (*DeleteChannelResp, error) {
	out := new(DeleteChannelResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/DeleteChannel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetChannelLabel(ctx context.Context, in *SetChannelLabelReq, opts ...grpc.CallOption) (*SetChannelLabelResp, error) {
	out := new(SetChannelLabelResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SetChannelLabel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetChannelVersion(ctx context.Context, in *SetChannelVersionReq, opts ...grpc.CallOption) (*SetChannelVersionResp, error) {
	out := new(SetChannelVersionResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SetChannelVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetChannelPublished(ctx context.Context, in *SetChannelPublishReq, opts ...grpc.CallOption) (*SetChannelPublishResp, error) {
	out := new(SetChannelPublishResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SetChannelPublished", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetChannelUpstream(ctx context.Context, in *SetChannelUpstreamReq, opts ...grpc.CallOption) (*SetChannelUpstreamResp, error) {
	out := new(SetChannelUpstreamResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SetChannelUpstream", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) DeleteChannelUpstream(ctx context.Context, in *DeleteChannelUpstreamReq, opts ...grpc.CallOption) (*DeleteChannelUpstreamResp, error) {
	out := new(DeleteChannelUpstreamResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/DeleteChannelUpstream", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) CreateGroup(ctx context.Context, in *CreateGroupReq, opts ...grpc.CallOption) (*CreateGroupResp, error) {
	out := new(CreateGroupResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/CreateGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) ListGroups(ctx context.Context, in *ListGroupsReq, opts ...grpc.CallOption) (*ListGroupsResp, error) {
	out := new(ListGroupsResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/ListGroups", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) GetGroup(ctx context.Context, in *GetGroupReq, opts ...grpc.CallOption) (*GetGroupResp, error) {
	out := new(GetGroupResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/GetGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) DeleteGroup(ctx context.Context, in *DeleteGroupReq, opts ...grpc.CallOption) (*DeleteGroupResp, error) {
	out := new(DeleteGroupResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/DeleteGroup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetGroupChannelID(ctx context.Context, in *SetGroupChannelIDReq, opts ...grpc.CallOption) (*SetGroupChannelIDResp, error) {
	out := new(SetGroupChannelIDResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SetGroupChannelID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetGroupLabel(ctx context.Context, in *SetGroupLabelReq, opts ...grpc.CallOption) (*SetGroupLabelResp, error) {
	out := new(SetGroupLabelResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SetGroupLabel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetGroupUpdateCount(ctx context.Context, in *SetGroupUpdateCountReq, opts ...grpc.CallOption) (*SetGroupUpdateCountResp, error) {
	out := new(SetGroupUpdateCountResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SetGroupUpdateCount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetGroupUpdateInterval(ctx context.Context, in *SetGroupUpdateIntervalReq, opts ...grpc.CallOption) (*SetGroupUpdateIntervalResp, error) {
	out := new(SetGroupUpdateIntervalResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SetGroupUpdateInterval", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetGroupUpdatesPausedState(ctx context.Context, in *SetGroupUpdatesPausedStateReq, opts ...grpc.CallOption) (*SetGroupUpdatesPausedStateResp, error) {
	out := new(SetGroupUpdatesPausedStateResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SetGroupUpdatesPausedState", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetGroupUpdatePooling(ctx context.Context, in *SetGroupUpdatePoolingReq, opts ...grpc.CallOption) (*SetGroupUpdatePoolingResp, error) {
	out := new(SetGroupUpdatePoolingResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SetGroupUpdatePooling", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetGroupOEMBlacklist(ctx context.Context, in *SetGroupOEMBlacklistReq, opts ...grpc.CallOption) (*SetGroupOEMBlacklistResp, error) {
	out := new(SetGroupOEMBlacklistResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SetGroupOEMBlacklist", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) GetGroupVersionsRollup(ctx context.Context, in *GetGroupVersionsRollupReq, opts ...grpc.CallOption) (*GetGroupVersionsRollupResp, error) {
	out := new(GetGroupVersionsRollupResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/GetGroupVersionsRollup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) GetGroupEventsRollup(ctx context.Context, in *GetGroupEventsRollupReq, opts ...grpc.CallOption) (*GetGroupEventsRollupResp, error) {
	out := new(GetGroupEventsRollupResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/GetGroupEventsRollup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) CreatePackage(ctx context.Context, in *CreatePackageReq, opts ...grpc.CallOption) (*CreatePackageResp, error) {
	out := new(CreatePackageResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/CreatePackage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) ListPackages(ctx context.Context, in *ListPackagesReq, opts ...grpc.CallOption) (*ListPackagesResp, error) {
	out := new(ListPackagesResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/ListPackages", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) GetPackage(ctx context.Context, in *GetPackageReq, opts ...grpc.CallOption) (*GetPackageResp, error) {
	out := new(GetPackageResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/GetPackage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) DeletePackage(ctx context.Context, in *DeletePackageReq, opts ...grpc.CallOption) (*DeletePackageResp, error) {
	out := new(DeletePackageResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/DeletePackage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) CreateUpstream(ctx context.Context, in *CreateUpstreamReq, opts ...grpc.CallOption) (*CreateUpstreamResp, error) {
	out := new(CreateUpstreamResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/CreateUpstream", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) ListUpstreams(ctx context.Context, in *ListUpstreamsReq, opts ...grpc.CallOption) (*ListUpstreamsResp, error) {
	out := new(ListUpstreamsResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/ListUpstreams", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) GetUpstream(ctx context.Context, in *GetUpstreamReq, opts ...grpc.CallOption) (*GetUpstreamResp, error) {
	out := new(GetUpstreamResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/GetUpstream", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) DeleteUpstream(ctx context.Context, in *DeleteUpstreamReq, opts ...grpc.CallOption) (*DeleteUpstreamResp, error) {
	out := new(DeleteUpstreamResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/DeleteUpstream", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SyncUpstreams(ctx context.Context, in *SyncUpstreamsReq, opts ...grpc.CallOption) (*SyncUpstreamsResp, error) {
	out := new(SyncUpstreamsResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SyncUpstreams", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetUpstreamURL(ctx context.Context, in *SetUpstreamURLReq, opts ...grpc.CallOption) (*SetUpstreamURLResp, error) {
	out := new(SetUpstreamURLResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SetUpstreamURL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) SetUpstreamLabel(ctx context.Context, in *SetUpstreamLabelReq, opts ...grpc.CallOption) (*SetUpstreamLabelResp, error) {
	out := new(SetUpstreamLabelResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/SetUpstreamLabel", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) GetClientHistory(ctx context.Context, in *GetClientHistoryReq, opts ...grpc.CallOption) (*GetClientHistoryResp, error) {
	out := new(GetClientHistoryResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/GetClientHistory", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) ListAppVersions(ctx context.Context, in *ListAppVersionsReq, opts ...grpc.CallOption) (*ListAppVersionsResp, error) {
	out := new(ListAppVersionsResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/ListAppVersions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) ListClientUpdates(ctx context.Context, in *ListClientUpdatesReq, opts ...grpc.CallOption) (*ListClientUpdatesResp, error) {
	out := new(ListClientUpdatesResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/ListClientUpdates", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) GetClientUpdateCount(ctx context.Context, in *GetClientUpdateCountReq, opts ...grpc.CallOption) (*GetClientUpdateCountResp, error) {
	out := new(GetClientUpdateCountResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/GetClientUpdateCount", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *updateServiceClient) GenerateUUID(ctx context.Context, in *GenerateUUIDReq, opts ...grpc.CallOption) (*GenerateUUIDResp, error) {
	out := new(GenerateUUIDResp)
	err := grpc.Invoke(ctx, "/update.UpdateService/GenerateUUID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for UpdateService service

type UpdateServiceServer interface {
	// users
	CreateUser(context.Context, *CreateUserReq) (*CreateUserResp, error)
	ListUsers(context.Context, *ListUsersReq) (*ListUsersResp, error)
	GetUser(context.Context, *GetUserReq) (*GetUserResp, error)
	DeleteUser(context.Context, *DeleteUserReq) (*DeleteUserResp, error)
	GenerateUserToken(context.Context, *GenerateUserTokenReq) (*GenerateUserTokenResp, error)
	// applications
	CreateApp(context.Context, *CreateAppReq) (*CreateAppResp, error)
	ListApps(context.Context, *ListAppsReq) (*ListAppsResp, error)
	GetApp(context.Context, *GetAppReq) (*GetAppResp, error)
	DeleteApp(context.Context, *DeleteAppReq) (*DeleteAppResp, error)
	SetAppLabel(context.Context, *SetAppLabelReq) (*SetAppLabelResp, error)
	SetAppDescription(context.Context, *SetAppDescriptionReq) (*SetAppDescriptionResp, error)
	// channels
	CreateChannel(context.Context, *CreateChannelReq) (*CreateChannelResp, error)
	ListChannels(context.Context, *ListChannelsReq) (*ListChannelsResp, error)
	GetChannel(context.Context, *GetChannelReq) (*GetChannelResp, error)
	DeleteChannel(context.Context, *DeleteChannelReq) (*DeleteChannelResp, error)
	SetChannelLabel(context.Context, *SetChannelLabelReq) (*SetChannelLabelResp, error)
	SetChannelVersion(context.Context, *SetChannelVersionReq) (*SetChannelVersionResp, error)
	SetChannelPublished(context.Context, *SetChannelPublishReq) (*SetChannelPublishResp, error)
	SetChannelUpstream(context.Context, *SetChannelUpstreamReq) (*SetChannelUpstreamResp, error)
	DeleteChannelUpstream(context.Context, *DeleteChannelUpstreamReq) (*DeleteChannelUpstreamResp, error)
	// groups
	CreateGroup(context.Context, *CreateGroupReq) (*CreateGroupResp, error)
	ListGroups(context.Context, *ListGroupsReq) (*ListGroupsResp, error)
	GetGroup(context.Context, *GetGroupReq) (*GetGroupResp, error)
	DeleteGroup(context.Context, *DeleteGroupReq) (*DeleteGroupResp, error)
	SetGroupChannelID(context.Context, *SetGroupChannelIDReq) (*SetGroupChannelIDResp, error)
	SetGroupLabel(context.Context, *SetGroupLabelReq) (*SetGroupLabelResp, error)
	SetGroupUpdateCount(context.Context, *SetGroupUpdateCountReq) (*SetGroupUpdateCountResp, error)
	SetGroupUpdateInterval(context.Context, *SetGroupUpdateIntervalReq) (*SetGroupUpdateIntervalResp, error)
	SetGroupUpdatesPausedState(context.Context, *SetGroupUpdatesPausedStateReq) (*SetGroupUpdatesPausedStateResp, error)
	SetGroupUpdatePooling(context.Context, *SetGroupUpdatePoolingReq) (*SetGroupUpdatePoolingResp, error)
	SetGroupOEMBlacklist(context.Context, *SetGroupOEMBlacklistReq) (*SetGroupOEMBlacklistResp, error)
	// rollup functions
	GetGroupVersionsRollup(context.Context, *GetGroupVersionsRollupReq) (*GetGroupVersionsRollupResp, error)
	GetGroupEventsRollup(context.Context, *GetGroupEventsRollupReq) (*GetGroupEventsRollupResp, error)
	// packages
	CreatePackage(context.Context, *CreatePackageReq) (*CreatePackageResp, error)
	ListPackages(context.Context, *ListPackagesReq) (*ListPackagesResp, error)
	GetPackage(context.Context, *GetPackageReq) (*GetPackageResp, error)
	DeletePackage(context.Context, *DeletePackageReq) (*DeletePackageResp, error)
	// upstreams
	CreateUpstream(context.Context, *CreateUpstreamReq) (*CreateUpstreamResp, error)
	ListUpstreams(context.Context, *ListUpstreamsReq) (*ListUpstreamsResp, error)
	GetUpstream(context.Context, *GetUpstreamReq) (*GetUpstreamResp, error)
	DeleteUpstream(context.Context, *DeleteUpstreamReq) (*DeleteUpstreamResp, error)
	SyncUpstreams(context.Context, *SyncUpstreamsReq) (*SyncUpstreamsResp, error)
	SetUpstreamURL(context.Context, *SetUpstreamURLReq) (*SetUpstreamURLResp, error)
	SetUpstreamLabel(context.Context, *SetUpstreamLabelReq) (*SetUpstreamLabelResp, error)
	// client requests
	GetClientHistory(context.Context, *GetClientHistoryReq) (*GetClientHistoryResp, error)
	// client updates
	ListAppVersions(context.Context, *ListAppVersionsReq) (*ListAppVersionsResp, error)
	ListClientUpdates(context.Context, *ListClientUpdatesReq) (*ListClientUpdatesResp, error)
	GetClientUpdateCount(context.Context, *GetClientUpdateCountReq) (*GetClientUpdateCountResp, error)
	// utility functions
	GenerateUUID(context.Context, *GenerateUUIDReq) (*GenerateUUIDResp, error)
}

func RegisterUpdateServiceServer(s *grpc.Server, srv UpdateServiceServer) {
	s.RegisterService(&_UpdateService_serviceDesc, srv)
}

func _UpdateService_CreateUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).CreateUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/CreateUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).CreateUser(ctx, req.(*CreateUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_ListUsers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsersReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).ListUsers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/ListUsers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).ListUsers(ctx, req.(*ListUsersReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_GetUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).GetUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/GetUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).GetUser(ctx, req.(*GetUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_DeleteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).DeleteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/DeleteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).DeleteUser(ctx, req.(*DeleteUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_GenerateUserToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateUserTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).GenerateUserToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/GenerateUserToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).GenerateUserToken(ctx, req.(*GenerateUserTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_CreateApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAppReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).CreateApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/CreateApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).CreateApp(ctx, req.(*CreateAppReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_ListApps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAppsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).ListApps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/ListApps",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).ListApps(ctx, req.(*ListAppsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_GetApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAppReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).GetApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/GetApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).GetApp(ctx, req.(*GetAppReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_DeleteApp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAppReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).DeleteApp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/DeleteApp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).DeleteApp(ctx, req.(*DeleteAppReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetAppLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAppLabelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetAppLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SetAppLabel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetAppLabel(ctx, req.(*SetAppLabelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetAppDescription_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAppDescriptionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetAppDescription(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SetAppDescription",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetAppDescription(ctx, req.(*SetAppDescriptionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_CreateChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).CreateChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/CreateChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).CreateChannel(ctx, req.(*CreateChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_ListChannels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListChannelsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).ListChannels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/ListChannels",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).ListChannels(ctx, req.(*ListChannelsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_GetChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).GetChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/GetChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).GetChannel(ctx, req.(*GetChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_DeleteChannel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChannelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).DeleteChannel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/DeleteChannel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).DeleteChannel(ctx, req.(*DeleteChannelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetChannelLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetChannelLabelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetChannelLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SetChannelLabel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetChannelLabel(ctx, req.(*SetChannelLabelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetChannelVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetChannelVersionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetChannelVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SetChannelVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetChannelVersion(ctx, req.(*SetChannelVersionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetChannelPublished_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetChannelPublishReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetChannelPublished(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SetChannelPublished",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetChannelPublished(ctx, req.(*SetChannelPublishReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetChannelUpstream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetChannelUpstreamReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetChannelUpstream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SetChannelUpstream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetChannelUpstream(ctx, req.(*SetChannelUpstreamReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_DeleteChannelUpstream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteChannelUpstreamReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).DeleteChannelUpstream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/DeleteChannelUpstream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).DeleteChannelUpstream(ctx, req.(*DeleteChannelUpstreamReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/CreateGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).CreateGroup(ctx, req.(*CreateGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_ListGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGroupsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).ListGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/ListGroups",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).ListGroups(ctx, req.(*ListGroupsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_GetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).GetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/GetGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).GetGroup(ctx, req.(*GetGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_DeleteGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGroupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).DeleteGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/DeleteGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).DeleteGroup(ctx, req.(*DeleteGroupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetGroupChannelID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGroupChannelIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetGroupChannelID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SetGroupChannelID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetGroupChannelID(ctx, req.(*SetGroupChannelIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetGroupLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGroupLabelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetGroupLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SetGroupLabel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetGroupLabel(ctx, req.(*SetGroupLabelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetGroupUpdateCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGroupUpdateCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetGroupUpdateCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SetGroupUpdateCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetGroupUpdateCount(ctx, req.(*SetGroupUpdateCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetGroupUpdateInterval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGroupUpdateIntervalReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetGroupUpdateInterval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SetGroupUpdateInterval",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetGroupUpdateInterval(ctx, req.(*SetGroupUpdateIntervalReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetGroupUpdatesPausedState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGroupUpdatesPausedStateReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetGroupUpdatesPausedState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SetGroupUpdatesPausedState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetGroupUpdatesPausedState(ctx, req.(*SetGroupUpdatesPausedStateReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetGroupUpdatePooling_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGroupUpdatePoolingReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetGroupUpdatePooling(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SetGroupUpdatePooling",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetGroupUpdatePooling(ctx, req.(*SetGroupUpdatePoolingReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetGroupOEMBlacklist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetGroupOEMBlacklistReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetGroupOEMBlacklist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SetGroupOEMBlacklist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetGroupOEMBlacklist(ctx, req.(*SetGroupOEMBlacklistReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_GetGroupVersionsRollup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroupVersionsRollupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).GetGroupVersionsRollup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/GetGroupVersionsRollup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).GetGroupVersionsRollup(ctx, req.(*GetGroupVersionsRollupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_GetGroupEventsRollup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroupEventsRollupReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).GetGroupEventsRollup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/GetGroupEventsRollup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).GetGroupEventsRollup(ctx, req.(*GetGroupEventsRollupReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_CreatePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePackageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).CreatePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/CreatePackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).CreatePackage(ctx, req.(*CreatePackageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_ListPackages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPackagesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).ListPackages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/ListPackages",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).ListPackages(ctx, req.(*ListPackagesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_GetPackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPackageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).GetPackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/GetPackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).GetPackage(ctx, req.(*GetPackageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_DeletePackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePackageReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).DeletePackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/DeletePackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).DeletePackage(ctx, req.(*DeletePackageReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_CreateUpstream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateUpstreamReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).CreateUpstream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/CreateUpstream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).CreateUpstream(ctx, req.(*CreateUpstreamReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_ListUpstreams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUpstreamsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).ListUpstreams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/ListUpstreams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).ListUpstreams(ctx, req.(*ListUpstreamsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_GetUpstream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUpstreamReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).GetUpstream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/GetUpstream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).GetUpstream(ctx, req.(*GetUpstreamReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_DeleteUpstream_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUpstreamReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).DeleteUpstream(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/DeleteUpstream",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).DeleteUpstream(ctx, req.(*DeleteUpstreamReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SyncUpstreams_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SyncUpstreamsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SyncUpstreams(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SyncUpstreams",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SyncUpstreams(ctx, req.(*SyncUpstreamsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetUpstreamURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUpstreamURLReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetUpstreamURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SetUpstreamURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetUpstreamURL(ctx, req.(*SetUpstreamURLReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_SetUpstreamLabel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUpstreamLabelReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).SetUpstreamLabel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/SetUpstreamLabel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).SetUpstreamLabel(ctx, req.(*SetUpstreamLabelReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_GetClientHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClientHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).GetClientHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/GetClientHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).GetClientHistory(ctx, req.(*GetClientHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_ListAppVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAppVersionsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).ListAppVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/ListAppVersions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).ListAppVersions(ctx, req.(*ListAppVersionsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_ListClientUpdates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListClientUpdatesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).ListClientUpdates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/ListClientUpdates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).ListClientUpdates(ctx, req.(*ListClientUpdatesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_GetClientUpdateCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetClientUpdateCountReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).GetClientUpdateCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/GetClientUpdateCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).GetClientUpdateCount(ctx, req.(*GetClientUpdateCountReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpdateService_GenerateUUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateUUIDReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpdateServiceServer).GenerateUUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/update.UpdateService/GenerateUUID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpdateServiceServer).GenerateUUID(ctx, req.(*GenerateUUIDReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _UpdateService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "update.UpdateService",
	HandlerType: (*UpdateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateUser",
			Handler:    _UpdateService_CreateUser_Handler,
		},
		{
			MethodName: "ListUsers",
			Handler:    _UpdateService_ListUsers_Handler,
		},
		{
			MethodName: "GetUser",
			Handler:    _UpdateService_GetUser_Handler,
		},
		{
			MethodName: "DeleteUser",
			Handler:    _UpdateService_DeleteUser_Handler,
		},
		{
			MethodName: "GenerateUserToken",
			Handler:    _UpdateService_GenerateUserToken_Handler,
		},
		{
			MethodName: "CreateApp",
			Handler:    _UpdateService_CreateApp_Handler,
		},
		{
			MethodName: "ListApps",
			Handler:    _UpdateService_ListApps_Handler,
		},
		{
			MethodName: "GetApp",
			Handler:    _UpdateService_GetApp_Handler,
		},
		{
			MethodName: "DeleteApp",
			Handler:    _UpdateService_DeleteApp_Handler,
		},
		{
			MethodName: "SetAppLabel",
			Handler:    _UpdateService_SetAppLabel_Handler,
		},
		{
			MethodName: "SetAppDescription",
			Handler:    _UpdateService_SetAppDescription_Handler,
		},
		{
			MethodName: "CreateChannel",
			Handler:    _UpdateService_CreateChannel_Handler,
		},
		{
			MethodName: "ListChannels",
			Handler:    _UpdateService_ListChannels_Handler,
		},
		{
			MethodName: "GetChannel",
			Handler:    _UpdateService_GetChannel_Handler,
		},
		{
			MethodName: "DeleteChannel",
			Handler:    _UpdateService_DeleteChannel_Handler,
		},
		{
			MethodName: "SetChannelLabel",
			Handler:    _UpdateService_SetChannelLabel_Handler,
		},
		{
			MethodName: "SetChannelVersion",
			Handler:    _UpdateService_SetChannelVersion_Handler,
		},
		{
			MethodName: "SetChannelPublished",
			Handler:    _UpdateService_SetChannelPublished_Handler,
		},
		{
			MethodName: "SetChannelUpstream",
			Handler:    _UpdateService_SetChannelUpstream_Handler,
		},
		{
			MethodName: "DeleteChannelUpstream",
			Handler:    _UpdateService_DeleteChannelUpstream_Handler,
		},
		{
			MethodName: "CreateGroup",
			Handler:    _UpdateService_CreateGroup_Handler,
		},
		{
			MethodName: "ListGroups",
			Handler:    _UpdateService_ListGroups_Handler,
		},
		{
			MethodName: "GetGroup",
			Handler:    _UpdateService_GetGroup_Handler,
		},
		{
			MethodName: "DeleteGroup",
			Handler:    _UpdateService_DeleteGroup_Handler,
		},
		{
			MethodName: "SetGroupChannelID",
			Handler:    _UpdateService_SetGroupChannelID_Handler,
		},
		{
			MethodName: "SetGroupLabel",
			Handler:    _UpdateService_SetGroupLabel_Handler,
		},
		{
			MethodName: "SetGroupUpdateCount",
			Handler:    _UpdateService_SetGroupUpdateCount_Handler,
		},
		{
			MethodName: "SetGroupUpdateInterval",
			Handler:    _UpdateService_SetGroupUpdateInterval_Handler,
		},
		{
			MethodName: "SetGroupUpdatesPausedState",
			Handler:    _UpdateService_SetGroupUpdatesPausedState_Handler,
		},
		{
			MethodName: "SetGroupUpdatePooling",
			Handler:    _UpdateService_SetGroupUpdatePooling_Handler,
		},
		{
			MethodName: "SetGroupOEMBlacklist",
			Handler:    _UpdateService_SetGroupOEMBlacklist_Handler,
		},
		{
			MethodName: "GetGroupVersionsRollup",
			Handler:    _UpdateService_GetGroupVersionsRollup_Handler,
		},
		{
			MethodName: "GetGroupEventsRollup",
			Handler:    _UpdateService_GetGroupEventsRollup_Handler,
		},
		{
			MethodName: "CreatePackage",
			Handler:    _UpdateService_CreatePackage_Handler,
		},
		{
			MethodName: "ListPackages",
			Handler:    _UpdateService_ListPackages_Handler,
		},
		{
			MethodName: "GetPackage",
			Handler:    _UpdateService_GetPackage_Handler,
		},
		{
			MethodName: "DeletePackage",
			Handler:    _UpdateService_DeletePackage_Handler,
		},
		{
			MethodName: "CreateUpstream",
			Handler:    _UpdateService_CreateUpstream_Handler,
		},
		{
			MethodName: "ListUpstreams",
			Handler:    _UpdateService_ListUpstreams_Handler,
		},
		{
			MethodName: "GetUpstream",
			Handler:    _UpdateService_GetUpstream_Handler,
		},
		{
			MethodName: "DeleteUpstream",
			Handler:    _UpdateService_DeleteUpstream_Handler,
		},
		{
			MethodName: "SyncUpstreams",
			Handler:    _UpdateService_SyncUpstreams_Handler,
		},
		{
			MethodName: "SetUpstreamURL",
			Handler:    _UpdateService_SetUpstreamURL_Handler,
		},
		{
			MethodName: "SetUpstreamLabel",
			Handler:    _UpdateService_SetUpstreamLabel_Handler,
		},
		{
			MethodName: "GetClientHistory",
			Handler:    _UpdateService_GetClientHistory_Handler,
		},
		{
			MethodName: "ListAppVersions",
			Handler:    _UpdateService_ListAppVersions_Handler,
		},
		{
			MethodName: "ListClientUpdates",
			Handler:    _UpdateService_ListClientUpdates_Handler,
		},
		{
			MethodName: "GetClientUpdateCount",
			Handler:    _UpdateService_GetClientUpdateCount_Handler,
		},
		{
			MethodName: "GenerateUUID",
			Handler:    _UpdateService_GenerateUUID_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: fileDescriptorApi,
}

func (m *User) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *User) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Username)))
		i += copy(data[i:], m.Username)
	}
	if len(m.Token) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Token)))
		i += copy(data[i:], m.Token)
	}
	return i, nil
}

func (m *App) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *App) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.Label) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	if len(m.Description) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	return i, nil
}

func (m *Channel) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Channel) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.AppID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.Label) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	if len(m.Version) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if m.Publish {
		data[i] = 0x28
		i++
		if m.Publish {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.UpstreamID) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintApi(data, i, uint64(len(m.UpstreamID)))
		i += copy(data[i:], m.UpstreamID)
	}
	if len(m.CreatedAt) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.CreatedAt)))
		i += copy(data[i:], m.CreatedAt)
	}
	return i, nil
}

func (m *Group) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Group) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.AppID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.ChannelID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ChannelID)))
		i += copy(data[i:], m.ChannelID)
	}
	if len(m.Label) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	if m.UpdateCount != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintApi(data, i, uint64(m.UpdateCount))
	}
	if m.UpdateInterval != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintApi(data, i, uint64(m.UpdateInterval))
	}
	if m.UpdatesPaused {
		data[i] = 0x38
		i++
		if m.UpdatesPaused {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.UpdatePooling {
		data[i] = 0x40
		i++
		if m.UpdatePooling {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.OEMBlacklist) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.OEMBlacklist)))
		i += copy(data[i:], m.OEMBlacklist)
	}
	return i, nil
}

func (m *Package) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Package) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.Version) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.URL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.URL)))
		i += copy(data[i:], m.URL)
	}
	if len(m.Size_) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Size_)))
		i += copy(data[i:], m.Size_)
	}
	if len(m.Sha1Sum) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Sha1Sum)))
		i += copy(data[i:], m.Sha1Sum)
	}
	if len(m.Sha256Sum) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Sha256Sum)))
		i += copy(data[i:], m.Sha256Sum)
	}
	if m.Required {
		data[i] = 0x38
		i++
		if m.Required {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.MetadataSignatureRsa) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintApi(data, i, uint64(len(m.MetadataSignatureRsa)))
		i += copy(data[i:], m.MetadataSignatureRsa)
	}
	if len(m.MetadataSize) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.MetadataSize)))
		i += copy(data[i:], m.MetadataSize)
	}
	if len(m.CreatedAt) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintApi(data, i, uint64(len(m.CreatedAt)))
		i += copy(data[i:], m.CreatedAt)
	}
	if len(m.ReleaseNotes) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ReleaseNotes)))
		i += copy(data[i:], m.ReleaseNotes)
	}
	return i, nil
}

func (m *Upstream) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Upstream) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.URL) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.URL)))
		i += copy(data[i:], m.URL)
	}
	if len(m.Label) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	return i, nil
}

func (m *CreateUserReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateUserReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Username)))
		i += copy(data[i:], m.Username)
	}
	return i, nil
}

func (m *CreateUserResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateUserResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.User != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.User.Size()))
		n1, err := m.User.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *ListUsersReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListUsersReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ListUsersResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListUsersResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetUserReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetUserReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Username)))
		i += copy(data[i:], m.Username)
	}
	return i, nil
}

func (m *GetUserResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetUserResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.User != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.User.Size()))
		n2, err := m.User.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *DeleteUserReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteUserReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Username)))
		i += copy(data[i:], m.Username)
	}
	return i, nil
}

func (m *DeleteUserResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteUserResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GenerateUserTokenReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GenerateUserTokenReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Username)))
		i += copy(data[i:], m.Username)
	}
	return i, nil
}

func (m *GenerateUserTokenResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GenerateUserTokenResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.User != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.User.Size()))
		n3, err := m.User.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	return i, nil
}

func (m *CreateAppReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateAppReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.Label) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	if len(m.Description) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	return i, nil
}

func (m *CreateAppResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateAppResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.App != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.App.Size()))
		n4, err := m.App.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *ListAppsReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListAppsReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ListAppsResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListAppsResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetAppReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetAppReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	return i, nil
}

func (m *GetAppResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetAppResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.App != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.App.Size()))
		n5, err := m.App.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *DeleteAppReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteAppReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	return i, nil
}

func (m *DeleteAppResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteAppResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SetAppLabelReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetAppLabelReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.Label) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	return i, nil
}

func (m *SetAppLabelResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetAppLabelResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.App != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.App.Size()))
		n6, err := m.App.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *SetAppDescriptionReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetAppDescriptionReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.Description) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Description)))
		i += copy(data[i:], m.Description)
	}
	return i, nil
}

func (m *SetAppDescriptionResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetAppDescriptionResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.App != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.App.Size()))
		n7, err := m.App.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *CreateChannelReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateChannelReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Label) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	if len(m.AppID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.Version) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if m.Publish {
		data[i] = 0x20
		i++
		if m.Publish {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.UpstreamID) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.UpstreamID)))
		i += copy(data[i:], m.UpstreamID)
	}
	return i, nil
}

func (m *CreateChannelResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateChannelResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Channel != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Channel.Size()))
		n8, err := m.Channel.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *ListChannelsReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListChannelsReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	return i, nil
}

func (m *ListChannelsResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListChannelsResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetChannelReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetChannelReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ChannelID)))
		i += copy(data[i:], m.ChannelID)
	}
	return i, nil
}

func (m *GetChannelResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetChannelResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Channel != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Channel.Size()))
		n9, err := m.Channel.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	return i, nil
}

func (m *DeleteChannelReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteChannelReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ChannelID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ChannelID)))
		i += copy(data[i:], m.ChannelID)
	}
	return i, nil
}

func (m *DeleteChannelResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteChannelResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SetChannelLabelReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetChannelLabelReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.Label) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	return i, nil
}

func (m *SetChannelLabelResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetChannelLabelResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Channel != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Channel.Size()))
		n10, err := m.Channel.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *SetChannelVersionReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetChannelVersionReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.Version) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	return i, nil
}

func (m *SetChannelVersionResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetChannelVersionResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Channel != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Channel.Size()))
		n11, err := m.Channel.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *SetChannelPublishReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetChannelPublishReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if m.Publish {
		data[i] = 0x10
		i++
		if m.Publish {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SetChannelPublishResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetChannelPublishResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Channel != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Channel.Size()))
		n12, err := m.Channel.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *SetChannelUpstreamReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetChannelUpstreamReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.UpstreamId) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.UpstreamId)))
		i += copy(data[i:], m.UpstreamId)
	}
	return i, nil
}

func (m *SetChannelUpstreamResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetChannelUpstreamResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Channel != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Channel.Size()))
		n13, err := m.Channel.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *DeleteChannelUpstreamReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteChannelUpstreamReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	return i, nil
}

func (m *DeleteChannelUpstreamResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteChannelUpstreamResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Channel != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Channel.Size()))
		n14, err := m.Channel.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *CreateGroupReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateGroupReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.AppID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.ChannelID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ChannelID)))
		i += copy(data[i:], m.ChannelID)
	}
	if len(m.Label) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	if m.UpdateCount != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintApi(data, i, uint64(m.UpdateCount))
	}
	if m.UpdateInterval != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintApi(data, i, uint64(m.UpdateInterval))
	}
	if m.UpdatesPaused {
		data[i] = 0x38
		i++
		if m.UpdatesPaused {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.UpdatePooling {
		data[i] = 0x40
		i++
		if m.UpdatePooling {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.OEMBlacklist) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.OEMBlacklist)))
		i += copy(data[i:], m.OEMBlacklist)
	}
	return i, nil
}

func (m *CreateGroupResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateGroupResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Group.Size()))
		n15, err := m.Group.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *ListGroupsReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListGroupsReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	return i, nil
}

func (m *ListGroupsResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListGroupsResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetGroupReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetGroupReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.AppID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	return i, nil
}

func (m *GetGroupResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetGroupResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Group.Size()))
		n16, err := m.Group.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *DeleteGroupReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteGroupReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.AppID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	return i, nil
}

func (m *DeleteGroupResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteGroupResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SetGroupChannelIDReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetGroupChannelIDReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.AppID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.ChannelID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ChannelID)))
		i += copy(data[i:], m.ChannelID)
	}
	return i, nil
}

func (m *SetGroupChannelIDResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetGroupChannelIDResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Group.Size()))
		n17, err := m.Group.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	return i, nil
}

func (m *SetGroupLabelReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetGroupLabelReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.AppID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.Label) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	return i, nil
}

func (m *SetGroupLabelResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetGroupLabelResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Group.Size()))
		n18, err := m.Group.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *SetGroupUpdateCountReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetGroupUpdateCountReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.AppID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if m.UpdateCount != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintApi(data, i, uint64(m.UpdateCount))
	}
	return i, nil
}

func (m *SetGroupUpdateCountResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetGroupUpdateCountResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Group.Size()))
		n19, err := m.Group.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *SetGroupUpdateIntervalReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetGroupUpdateIntervalReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.AppID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if m.UpdateInterval != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintApi(data, i, uint64(m.UpdateInterval))
	}
	return i, nil
}

func (m *SetGroupUpdateIntervalResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetGroupUpdateIntervalResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Group.Size()))
		n20, err := m.Group.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *SetGroupUpdatesPausedStateReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetGroupUpdatesPausedStateReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.AppID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if m.UpdatesPaused {
		data[i] = 0x18
		i++
		if m.UpdatesPaused {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SetGroupUpdatesPausedStateResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetGroupUpdatesPausedStateResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Group.Size()))
		n21, err := m.Group.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	return i, nil
}

func (m *SetGroupUpdatePoolingReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetGroupUpdatePoolingReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.AppID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if m.UpdatePooling {
		data[i] = 0x18
		i++
		if m.UpdatePooling {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SetGroupUpdatePoolingResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetGroupUpdatePoolingResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Group.Size()))
		n22, err := m.Group.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	return i, nil
}

func (m *SetGroupOEMBlacklistReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetGroupOEMBlacklistReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.AppID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.OEMBlacklist) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.OEMBlacklist)))
		i += copy(data[i:], m.OEMBlacklist)
	}
	return i, nil
}

func (m *SetGroupOEMBlacklistResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetGroupOEMBlacklistResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Group.Size()))
		n23, err := m.Group.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *GroupRequestsValues) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GroupRequestsValues) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintApi(data, i, uint64(m.Timestamp))
	}
	if m.Count != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintApi(data, i, uint64(m.Count))
	}
	return i, nil
}

func (m *GetGroupVersionsRollupReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetGroupVersionsRollupReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.GroupID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.GroupID)))
		i += copy(data[i:], m.GroupID)
	}
	if m.DateStart != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintApi(data, i, uint64(m.DateStart))
	}
	if m.DateEnd != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintApi(data, i, uint64(m.DateEnd))
	}
	if m.Resolution != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintApi(data, i, uint64(m.Resolution))
	}
	if len(m.Versions) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Versions)))
		i += copy(data[i:], m.Versions)
	}
	return i, nil
}

func (m *GroupVersionsItem) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GroupVersionsItem) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.Values) > 0 {
		for _, msg := range m.Values {
			data[i] = 0x22
			i++
			i = encodeVarintApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetGroupVersionsRollupResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetGroupVersionsRollupResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetGroupEventsRollupReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetGroupEventsRollupReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.GroupID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.GroupID)))
		i += copy(data[i:], m.GroupID)
	}
	if m.DateStart != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintApi(data, i, uint64(m.DateStart))
	}
	if m.DateEnd != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintApi(data, i, uint64(m.DateEnd))
	}
	if m.Resolution != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintApi(data, i, uint64(m.Resolution))
	}
	if len(m.Versions) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Versions)))
		i += copy(data[i:], m.Versions)
	}
	return i, nil
}

func (m *GroupEventsItem) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GroupEventsItem) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if m.EventType != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintApi(data, i, uint64(m.EventType))
	}
	if m.EventResult != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintApi(data, i, uint64(m.EventResult))
	}
	if len(m.Values) > 0 {
		for _, msg := range m.Values {
			data[i] = 0x22
			i++
			i = encodeVarintApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetGroupEventsRollupResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetGroupEventsRollupResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CreatePackageReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreatePackageReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.Version) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.URL) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.URL)))
		i += copy(data[i:], m.URL)
	}
	if len(m.Size_) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Size_)))
		i += copy(data[i:], m.Size_)
	}
	if len(m.Sha1Sum) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Sha1Sum)))
		i += copy(data[i:], m.Sha1Sum)
	}
	if len(m.Sha256Sum) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Sha256Sum)))
		i += copy(data[i:], m.Sha256Sum)
	}
	if m.Required {
		data[i] = 0x38
		i++
		if m.Required {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.MetadataSignatureRsa) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintApi(data, i, uint64(len(m.MetadataSignatureRsa)))
		i += copy(data[i:], m.MetadataSignatureRsa)
	}
	if len(m.MetadataSize) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.MetadataSize)))
		i += copy(data[i:], m.MetadataSize)
	}
	if len(m.ReleaseNotes) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ReleaseNotes)))
		i += copy(data[i:], m.ReleaseNotes)
	}
	return i, nil
}

func (m *CreatePackageResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreatePackageResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Package != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Package.Size()))
		n24, err := m.Package.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *ListPackagesReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListPackagesReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if m.Limit != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintApi(data, i, uint64(m.Limit))
	}
	if m.Skip != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintApi(data, i, uint64(m.Skip))
	}
	return i, nil
}

func (m *ListPackagesResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListPackagesResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Total != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintApi(data, i, uint64(m.Total))
	}
	return i, nil
}

func (m *GetPackageReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetPackageReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.Version) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	return i, nil
}

func (m *GetPackageResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetPackageResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Package != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Package.Size()))
		n25, err := m.Package.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *DeletePackageReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeletePackageReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.Version) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	return i, nil
}

func (m *DeletePackageResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeletePackageResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *CreateUpstreamReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateUpstreamReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.URL) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.URL)))
		i += copy(data[i:], m.URL)
	}
	if len(m.Label) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	return i, nil
}

func (m *CreateUpstreamResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CreateUpstreamResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Upstream != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Upstream.Size()))
		n26, err := m.Upstream.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *ListUpstreamsReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListUpstreamsReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ListUpstreamsResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListUpstreamsResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetUpstreamReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetUpstreamReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	return i, nil
}

func (m *GetUpstreamResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetUpstreamResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Upstream != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Upstream.Size()))
		n27, err := m.Upstream.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *DeleteUpstreamReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteUpstreamReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	return i, nil
}

func (m *DeleteUpstreamResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DeleteUpstreamResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SyncUpstreamsReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SyncUpstreamsReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SyncUpstreamsResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SyncUpstreamsResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Status) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Status)))
		i += copy(data[i:], m.Status)
	}
	if len(m.Detail) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Detail)))
		i += copy(data[i:], m.Detail)
	}
	return i, nil
}

func (m *SetUpstreamURLReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetUpstreamURLReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.URL) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.URL)))
		i += copy(data[i:], m.URL)
	}
	return i, nil
}

func (m *SetUpstreamURLResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetUpstreamURLResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Upstream != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Upstream.Size()))
		n28, err := m.Upstream.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *SetUpstreamLabelReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetUpstreamLabelReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ID)))
		i += copy(data[i:], m.ID)
	}
	if len(m.Label) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Label)))
		i += copy(data[i:], m.Label)
	}
	return i, nil
}

func (m *SetUpstreamLabelResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SetUpstreamLabelResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Upstream != nil {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(m.Upstream.Size()))
		n29, err := m.Upstream.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}

func (m *GetClientHistoryReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetClientHistoryReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ClientID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ClientID)))
		i += copy(data[i:], m.ClientID)
	}
	return i, nil
}

func (m *GetClientHistoryItem) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetClientHistoryItem) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DateTime != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintApi(data, i, uint64(m.DateTime))
	}
	if m.EventType != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintApi(data, i, uint64(m.EventType))
	}
	if m.EventResult != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintApi(data, i, uint64(m.EventResult))
	}
	if m.ErrorCode != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintApi(data, i, uint64(m.ErrorCode))
	}
	if len(m.Version) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.GroupID) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintApi(data, i, uint64(len(m.GroupID)))
		i += copy(data[i:], m.GroupID)
	}
	if len(m.InstallSource) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.InstallSource)))
		i += copy(data[i:], m.InstallSource)
	}
	return i, nil
}

func (m *GetClientHistoryResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetClientHistoryResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ListAppVersionsReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListAppVersionsReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DateStart != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintApi(data, i, uint64(m.DateStart))
	}
	if m.DateEnd != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintApi(data, i, uint64(m.DateEnd))
	}
	if len(m.AppID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.GroupID) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintApi(data, i, uint64(len(m.GroupID)))
		i += copy(data[i:], m.GroupID)
	}
	if len(m.Version) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.OEM) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintApi(data, i, uint64(len(m.OEM)))
		i += copy(data[i:], m.OEM)
	}
	if m.EventType != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintApi(data, i, uint64(m.EventType))
	}
	if m.EventResult != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintApi(data, i, uint64(m.EventResult))
	}
	return i, nil
}

func (m *AppVersionItem) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AppVersionItem) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.GroupID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.GroupID)))
		i += copy(data[i:], m.GroupID)
	}
	if len(m.Version) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.Count) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Count)))
		i += copy(data[i:], m.Count)
	}
	return i, nil
}

func (m *ListAppVersionsResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListAppVersionsResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ListClientUpdatesReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListClientUpdatesReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DateStart != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintApi(data, i, uint64(m.DateStart))
	}
	if m.DateEnd != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintApi(data, i, uint64(m.DateEnd))
	}
	if len(m.AppID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.GroupID) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintApi(data, i, uint64(len(m.GroupID)))
		i += copy(data[i:], m.GroupID)
	}
	if len(m.Version) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.OEM) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintApi(data, i, uint64(len(m.OEM)))
		i += copy(data[i:], m.OEM)
	}
	if m.EventType != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintApi(data, i, uint64(m.EventType))
	}
	if m.EventResult != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintApi(data, i, uint64(m.EventResult))
	}
	if len(m.ClientID) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ClientID)))
		i += copy(data[i:], m.ClientID)
	}
	if m.Limit != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintApi(data, i, uint64(m.Limit))
	}
	if m.Skip != 0 {
		data[i] = 0x58
		i++
		i = encodeVarintApi(data, i, uint64(m.Skip))
	}
	return i, nil
}

func (m *ClientUpdate) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ClientUpdate) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.AppID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.ClientID) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintApi(data, i, uint64(len(m.ClientID)))
		i += copy(data[i:], m.ClientID)
	}
	if len(m.GroupID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.GroupID)))
		i += copy(data[i:], m.GroupID)
	}
	if len(m.Version) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.LastSeen) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.LastSeen)))
		i += copy(data[i:], m.LastSeen)
	}
	if m.EventType != 0 {
		data[i] = 0x30
		i++
		i = encodeVarintApi(data, i, uint64(m.EventType))
	}
	if m.EventResult != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintApi(data, i, uint64(m.EventResult))
	}
	if m.ErrorCode != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintApi(data, i, uint64(m.ErrorCode))
	}
	if len(m.OEM) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.OEM)))
		i += copy(data[i:], m.OEM)
	}
	return i, nil
}

func (m *ListClientUpdatesResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ListClientUpdatesResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			data[i] = 0xa
			i++
			i = encodeVarintApi(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *GetClientUpdateCountReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetClientUpdateCountReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.DateStart != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintApi(data, i, uint64(m.DateStart))
	}
	if m.DateEnd != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintApi(data, i, uint64(m.DateEnd))
	}
	if len(m.AppID) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.AppID)))
		i += copy(data[i:], m.AppID)
	}
	if len(m.GroupID) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintApi(data, i, uint64(len(m.GroupID)))
		i += copy(data[i:], m.GroupID)
	}
	if len(m.Version) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintApi(data, i, uint64(len(m.Version)))
		i += copy(data[i:], m.Version)
	}
	if len(m.OEM) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintApi(data, i, uint64(len(m.OEM)))
		i += copy(data[i:], m.OEM)
	}
	if m.EventType != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintApi(data, i, uint64(m.EventType))
	}
	if m.EventResult != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintApi(data, i, uint64(m.EventResult))
	}
	return i, nil
}

func (m *GetClientUpdateCountResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GetClientUpdateCountResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintApi(data, i, uint64(m.Count))
	}
	return i, nil
}

func (m *GenerateUUIDReq) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GenerateUUIDReq) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *GenerateUUIDResp) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *GenerateUUIDResp) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.UUID) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintApi(data, i, uint64(len(m.UUID)))
		i += copy(data[i:], m.UUID)
	}
	return i, nil
}

func encodeFixed64Api(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Api(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintApi(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *User) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *App) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Channel) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Publish {
		n += 2
	}
	l = len(m.UpstreamID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Group) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ChannelID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.UpdateCount != 0 {
		n += 1 + sovApi(uint64(m.UpdateCount))
	}
	if m.UpdateInterval != 0 {
		n += 1 + sovApi(uint64(m.UpdateInterval))
	}
	if m.UpdatesPaused {
		n += 2
	}
	if m.UpdatePooling {
		n += 2
	}
	l = len(m.OEMBlacklist)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Package) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Size_)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Sha1Sum)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Sha256Sum)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Required {
		n += 2
	}
	l = len(m.MetadataSignatureRsa)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.MetadataSize)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.CreatedAt)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ReleaseNotes)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *Upstream) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *CreateUserReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *CreateUserResp) Size() (n int) {
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ListUsersReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ListUsersResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *GetUserReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GetUserResp) Size() (n int) {
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DeleteUserReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DeleteUserResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GenerateUserTokenReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GenerateUserTokenResp) Size() (n int) {
	var l int
	_ = l
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *CreateAppReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *CreateAppResp) Size() (n int) {
	var l int
	_ = l
	if m.App != nil {
		l = m.App.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ListAppsReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ListAppsResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *GetAppReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GetAppResp) Size() (n int) {
	var l int
	_ = l
	if m.App != nil {
		l = m.App.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DeleteAppReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DeleteAppResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SetAppLabelReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetAppLabelResp) Size() (n int) {
	var l int
	_ = l
	if m.App != nil {
		l = m.App.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetAppDescriptionReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetAppDescriptionResp) Size() (n int) {
	var l int
	_ = l
	if m.App != nil {
		l = m.App.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *CreateChannelReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Publish {
		n += 2
	}
	l = len(m.UpstreamID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *CreateChannelResp) Size() (n int) {
	var l int
	_ = l
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ListChannelsReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ListChannelsResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *GetChannelReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChannelID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GetChannelResp) Size() (n int) {
	var l int
	_ = l
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DeleteChannelReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ChannelID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DeleteChannelResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SetChannelLabelReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetChannelLabelResp) Size() (n int) {
	var l int
	_ = l
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetChannelVersionReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetChannelVersionResp) Size() (n int) {
	var l int
	_ = l
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetChannelPublishReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Publish {
		n += 2
	}
	return n
}

func (m *SetChannelPublishResp) Size() (n int) {
	var l int
	_ = l
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetChannelUpstreamReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.UpstreamId)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetChannelUpstreamResp) Size() (n int) {
	var l int
	_ = l
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DeleteChannelUpstreamReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DeleteChannelUpstreamResp) Size() (n int) {
	var l int
	_ = l
	if m.Channel != nil {
		l = m.Channel.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *CreateGroupReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ChannelID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.UpdateCount != 0 {
		n += 1 + sovApi(uint64(m.UpdateCount))
	}
	if m.UpdateInterval != 0 {
		n += 1 + sovApi(uint64(m.UpdateInterval))
	}
	if m.UpdatesPaused {
		n += 2
	}
	if m.UpdatePooling {
		n += 2
	}
	l = len(m.OEMBlacklist)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *CreateGroupResp) Size() (n int) {
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ListGroupsReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ListGroupsResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *GetGroupReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GetGroupResp) Size() (n int) {
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DeleteGroupReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DeleteGroupResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SetGroupChannelIDReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ChannelID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetGroupChannelIDResp) Size() (n int) {
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetGroupLabelReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetGroupLabelResp) Size() (n int) {
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetGroupUpdateCountReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.UpdateCount != 0 {
		n += 1 + sovApi(uint64(m.UpdateCount))
	}
	return n
}

func (m *SetGroupUpdateCountResp) Size() (n int) {
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetGroupUpdateIntervalReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.UpdateInterval != 0 {
		n += 1 + sovApi(uint64(m.UpdateInterval))
	}
	return n
}

func (m *SetGroupUpdateIntervalResp) Size() (n int) {
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetGroupUpdatesPausedStateReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.UpdatesPaused {
		n += 2
	}
	return n
}

func (m *SetGroupUpdatesPausedStateResp) Size() (n int) {
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetGroupUpdatePoolingReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.UpdatePooling {
		n += 2
	}
	return n
}

func (m *SetGroupUpdatePoolingResp) Size() (n int) {
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetGroupOEMBlacklistReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.OEMBlacklist)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetGroupOEMBlacklistResp) Size() (n int) {
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GroupRequestsValues) Size() (n int) {
	var l int
	_ = l
	if m.Timestamp != 0 {
		n += 1 + sovApi(uint64(m.Timestamp))
	}
	if m.Count != 0 {
		n += 1 + sovApi(uint64(m.Count))
	}
	return n
}

func (m *GetGroupVersionsRollupReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.GroupID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DateStart != 0 {
		n += 1 + sovApi(uint64(m.DateStart))
	}
	if m.DateEnd != 0 {
		n += 1 + sovApi(uint64(m.DateEnd))
	}
	if m.Resolution != 0 {
		n += 1 + sovApi(uint64(m.Resolution))
	}
	l = len(m.Versions)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GroupVersionsItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *GetGroupVersionsRollupResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *GetGroupEventsRollupReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.GroupID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.DateStart != 0 {
		n += 1 + sovApi(uint64(m.DateStart))
	}
	if m.DateEnd != 0 {
		n += 1 + sovApi(uint64(m.DateEnd))
	}
	if m.Resolution != 0 {
		n += 1 + sovApi(uint64(m.Resolution))
	}
	l = len(m.Versions)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GroupEventsItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EventType != 0 {
		n += 1 + sovApi(uint64(m.EventType))
	}
	if m.EventResult != 0 {
		n += 1 + sovApi(uint64(m.EventResult))
	}
	if len(m.Values) > 0 {
		for _, e := range m.Values {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *GetGroupEventsRollupResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *CreatePackageReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Size_)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Sha1Sum)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Sha256Sum)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Required {
		n += 2
	}
	l = len(m.MetadataSignatureRsa)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.MetadataSize)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ReleaseNotes)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *CreatePackageResp) Size() (n int) {
	var l int
	_ = l
	if m.Package != nil {
		l = m.Package.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ListPackagesReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovApi(uint64(m.Limit))
	}
	if m.Skip != 0 {
		n += 1 + sovApi(uint64(m.Skip))
	}
	return n
}

func (m *ListPackagesResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Total != 0 {
		n += 1 + sovApi(uint64(m.Total))
	}
	return n
}

func (m *GetPackageReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GetPackageResp) Size() (n int) {
	var l int
	_ = l
	if m.Package != nil {
		l = m.Package.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DeletePackageReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DeletePackageResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *CreateUpstreamReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *CreateUpstreamResp) Size() (n int) {
	var l int
	_ = l
	if m.Upstream != nil {
		l = m.Upstream.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ListUpstreamsReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ListUpstreamsResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *GetUpstreamReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GetUpstreamResp) Size() (n int) {
	var l int
	_ = l
	if m.Upstream != nil {
		l = m.Upstream.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DeleteUpstreamReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DeleteUpstreamResp) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SyncUpstreamsReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *SyncUpstreamsResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.Status)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Detail)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetUpstreamURLReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.URL)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetUpstreamURLResp) Size() (n int) {
	var l int
	_ = l
	if m.Upstream != nil {
		l = m.Upstream.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetUpstreamLabelReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Label)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SetUpstreamLabelResp) Size() (n int) {
	var l int
	_ = l
	if m.Upstream != nil {
		l = m.Upstream.Size()
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GetClientHistoryReq) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GetClientHistoryItem) Size() (n int) {
	var l int
	_ = l
	if m.DateTime != 0 {
		n += 1 + sovApi(uint64(m.DateTime))
	}
	if m.EventType != 0 {
		n += 1 + sovApi(uint64(m.EventType))
	}
	if m.EventResult != 0 {
		n += 1 + sovApi(uint64(m.EventResult))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovApi(uint64(m.ErrorCode))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.GroupID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.InstallSource)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *GetClientHistoryResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ListAppVersionsReq) Size() (n int) {
	var l int
	_ = l
	if m.DateStart != 0 {
		n += 1 + sovApi(uint64(m.DateStart))
	}
	if m.DateEnd != 0 {
		n += 1 + sovApi(uint64(m.DateEnd))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.GroupID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.OEM)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EventType != 0 {
		n += 1 + sovApi(uint64(m.EventType))
	}
	if m.EventResult != 0 {
		n += 1 + sovApi(uint64(m.EventResult))
	}
	return n
}

func (m *AppVersionItem) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.GroupID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Count)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ListAppVersionsResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *ListClientUpdatesReq) Size() (n int) {
	var l int
	_ = l
	if m.DateStart != 0 {
		n += 1 + sovApi(uint64(m.DateStart))
	}
	if m.DateEnd != 0 {
		n += 1 + sovApi(uint64(m.DateEnd))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.GroupID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.OEM)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EventType != 0 {
		n += 1 + sovApi(uint64(m.EventType))
	}
	if m.EventResult != 0 {
		n += 1 + sovApi(uint64(m.EventResult))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovApi(uint64(m.Limit))
	}
	if m.Skip != 0 {
		n += 1 + sovApi(uint64(m.Skip))
	}
	return n
}

func (m *ClientUpdate) Size() (n int) {
	var l int
	_ = l
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.ClientID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.GroupID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.LastSeen)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EventType != 0 {
		n += 1 + sovApi(uint64(m.EventType))
	}
	if m.EventResult != 0 {
		n += 1 + sovApi(uint64(m.EventResult))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovApi(uint64(m.ErrorCode))
	}
	l = len(m.OEM)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *ListClientUpdatesResp) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *GetClientUpdateCountReq) Size() (n int) {
	var l int
	_ = l
	if m.DateStart != 0 {
		n += 1 + sovApi(uint64(m.DateStart))
	}
	if m.DateEnd != 0 {
		n += 1 + sovApi(uint64(m.DateEnd))
	}
	l = len(m.AppID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.GroupID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.OEM)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.EventType != 0 {
		n += 1 + sovApi(uint64(m.EventType))
	}
	if m.EventResult != 0 {
		n += 1 + sovApi(uint64(m.EventResult))
	}
	return n
}

func (m *GetClientUpdateCountResp) Size() (n int) {
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovApi(uint64(m.Count))
	}
	return n
}

func (m *GenerateUUIDReq) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *GenerateUUIDResp) Size() (n int) {
	var l int
	_ = l
	l = len(m.UUID)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *User) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: User: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: User: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *App) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: App: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: App: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Channel) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Channel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Channel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Publish = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpstreamID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCount", wireType)
			}
			m.UpdateCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UpdateCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateInterval", wireType)
			}
			m.UpdateInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UpdateInterval |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatesPaused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdatesPaused = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatePooling", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdatePooling = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OEMBlacklist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OEMBlacklist = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Package) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Package: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Package: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Size_ = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha1Sum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha1Sum = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256Sum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha256Sum = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataSignatureRsa", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataSignatureRsa = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataSize = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreatedAt = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseNotes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReleaseNotes = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Upstream) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Upstream: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Upstream: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateUserReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateUserResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateUserResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateUserResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUsersReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUsersReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUsersReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUsersResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUsersResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUsersResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &User{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUserResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUserResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUserResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUserResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUserResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUserResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateUserTokenReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateUserTokenReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateUserTokenReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateUserTokenResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateUserTokenResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateUserTokenResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &User{}
			}
			if err := m.User.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAppReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAppReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAppReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateAppResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateAppResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateAppResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.App == nil {
				m.App = &App{}
			}
			if err := m.App.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAppsReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAppsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAppsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAppsResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAppsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAppsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &App{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAppReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAppReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAppReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAppResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAppResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAppResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.App == nil {
				m.App = &App{}
			}
			if err := m.App.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAppReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAppReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAppReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteAppResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteAppResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteAppResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetAppLabelReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetAppLabelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetAppLabelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetAppLabelResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetAppLabelResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetAppLabelResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.App == nil {
				m.App = &App{}
			}
			if err := m.App.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetAppDescriptionReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetAppDescriptionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetAppDescriptionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetAppDescriptionResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetAppDescriptionResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetAppDescriptionResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field App", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.App == nil {
				m.App = &App{}
			}
			if err := m.App.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateChannelReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateChannelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateChannelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Publish = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpstreamID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateChannelResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateChannelResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateChannelResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Channel == nil {
				m.Channel = &Channel{}
			}
			if err := m.Channel.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListChannelsReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListChannelsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListChannelsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListChannelsResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListChannelsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListChannelsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Channel{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetChannelResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetChannelResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetChannelResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Channel == nil {
				m.Channel = &Channel{}
			}
			if err := m.Channel.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteChannelReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteChannelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteChannelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteChannelResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteChannelResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteChannelResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChannelLabelReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetChannelLabelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetChannelLabelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChannelLabelResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetChannelLabelResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetChannelLabelResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Channel == nil {
				m.Channel = &Channel{}
			}
			if err := m.Channel.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChannelVersionReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetChannelVersionReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetChannelVersionReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChannelVersionResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetChannelVersionResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetChannelVersionResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Channel == nil {
				m.Channel = &Channel{}
			}
			if err := m.Channel.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChannelPublishReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetChannelPublishReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetChannelPublishReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Publish", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Publish = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChannelPublishResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetChannelPublishResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetChannelPublishResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Channel == nil {
				m.Channel = &Channel{}
			}
			if err := m.Channel.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChannelUpstreamReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetChannelUpstreamReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetChannelUpstreamReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpstreamId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpstreamId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetChannelUpstreamResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetChannelUpstreamResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetChannelUpstreamResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Channel == nil {
				m.Channel = &Channel{}
			}
			if err := m.Channel.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteChannelUpstreamReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteChannelUpstreamReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteChannelUpstreamReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteChannelUpstreamResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteChannelUpstreamResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteChannelUpstreamResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Channel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Channel == nil {
				m.Channel = &Channel{}
			}
			if err := m.Channel.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateGroupReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateGroupReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateGroupReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCount", wireType)
			}
			m.UpdateCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UpdateCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateInterval", wireType)
			}
			m.UpdateInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UpdateInterval |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatesPaused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdatesPaused = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatePooling", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdatePooling = bool(v != 0)
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OEMBlacklist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OEMBlacklist = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateGroupResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateGroupResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateGroupResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListGroupsReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListGroupsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListGroupsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListGroupsResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListGroupsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListGroupsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Group{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGroupReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGroupReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGroupReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGroupResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGroupResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGroupResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteGroupReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteGroupReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteGroupReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteGroupResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteGroupResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteGroupResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetGroupChannelIDReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetGroupChannelIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetGroupChannelIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChannelID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetGroupChannelIDResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetGroupChannelIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetGroupChannelIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetGroupLabelReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetGroupLabelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetGroupLabelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetGroupLabelResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetGroupLabelResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetGroupLabelResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetGroupUpdateCountReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetGroupUpdateCountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetGroupUpdateCountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateCount", wireType)
			}
			m.UpdateCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UpdateCount |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetGroupUpdateCountResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetGroupUpdateCountResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetGroupUpdateCountResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetGroupUpdateIntervalReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetGroupUpdateIntervalReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetGroupUpdateIntervalReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateInterval", wireType)
			}
			m.UpdateInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.UpdateInterval |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetGroupUpdateIntervalResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetGroupUpdateIntervalResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetGroupUpdateIntervalResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetGroupUpdatesPausedStateReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetGroupUpdatesPausedStateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetGroupUpdatesPausedStateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatesPaused", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdatesPaused = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetGroupUpdatesPausedStateResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetGroupUpdatesPausedStateResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetGroupUpdatesPausedStateResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetGroupUpdatePoolingReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetGroupUpdatePoolingReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetGroupUpdatePoolingReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatePooling", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdatePooling = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetGroupUpdatePoolingResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetGroupUpdatePoolingResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetGroupUpdatePoolingResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetGroupOEMBlacklistReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetGroupOEMBlacklistReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetGroupOEMBlacklistReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OEMBlacklist", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OEMBlacklist = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetGroupOEMBlacklistResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetGroupOEMBlacklistResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetGroupOEMBlacklistResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupRequestsValues) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupRequestsValues: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupRequestsValues: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Timestamp |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGroupVersionsRollupReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGroupVersionsRollupReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGroupVersionsRollupReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateStart", wireType)
			}
			m.DateStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DateStart |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnd", wireType)
			}
			m.DateEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DateEnd |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			m.Resolution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Resolution |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Versions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Versions = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupVersionsItem) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupVersionsItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupVersionsItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &GroupRequestsValues{})
			if err := m.Values[len(m.Values)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGroupVersionsRollupResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGroupVersionsRollupResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGroupVersionsRollupResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &GroupVersionsItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGroupEventsRollupReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGroupEventsRollupReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGroupEventsRollupReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateStart", wireType)
			}
			m.DateStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DateStart |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnd", wireType)
			}
			m.DateEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DateEnd |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resolution", wireType)
			}
			m.Resolution = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Resolution |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Versions", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Versions = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupEventsItem) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupEventsItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupEventsItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EventType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventResult", wireType)
			}
			m.EventResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EventResult |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, &GroupRequestsValues{})
			if err := m.Values[len(m.Values)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetGroupEventsRollupResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetGroupEventsRollupResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetGroupEventsRollupResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &GroupEventsItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePackageReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePackageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePackageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Size_ = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha1Sum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha1Sum = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sha256Sum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sha256Sum = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Required", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Required = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataSignatureRsa", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataSignatureRsa = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MetadataSize", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MetadataSize = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReleaseNotes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReleaseNotes = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreatePackageResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreatePackageResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreatePackageResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Package == nil {
				m.Package = &Package{}
			}
			if err := m.Package.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListPackagesReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListPackagesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListPackagesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Limit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skip", wireType)
			}
			m.Skip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Skip |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListPackagesResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListPackagesResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListPackagesResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Package{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Total", wireType)
			}
			m.Total = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Total |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPackageReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPackageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPackageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPackageResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPackageResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPackageResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Package", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Package == nil {
				m.Package = &Package{}
			}
			if err := m.Package.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePackageReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePackageReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePackageReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeletePackageResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeletePackageResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeletePackageResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateUpstreamReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateUpstreamReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateUpstreamReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateUpstreamResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateUpstreamResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateUpstreamResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upstream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Upstream == nil {
				m.Upstream = &Upstream{}
			}
			if err := m.Upstream.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUpstreamsReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUpstreamsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUpstreamsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListUpstreamsResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListUpstreamsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListUpstreamsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Upstream{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUpstreamReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUpstreamReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUpstreamReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetUpstreamResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetUpstreamResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetUpstreamResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upstream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Upstream == nil {
				m.Upstream = &Upstream{}
			}
			if err := m.Upstream.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUpstreamReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUpstreamReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUpstreamReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteUpstreamResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteUpstreamResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteUpstreamResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncUpstreamsReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncUpstreamsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncUpstreamsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncUpstreamsResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncUpstreamsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncUpstreamsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Status = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Detail = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetUpstreamURLReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetUpstreamURLReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetUpstreamURLReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field URL", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.URL = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetUpstreamURLResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetUpstreamURLResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetUpstreamURLResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upstream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Upstream == nil {
				m.Upstream = &Upstream{}
			}
			if err := m.Upstream.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetUpstreamLabelReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetUpstreamLabelReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetUpstreamLabelReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Label", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Label = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetUpstreamLabelResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SetUpstreamLabelResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SetUpstreamLabelResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Upstream", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Upstream == nil {
				m.Upstream = &Upstream{}
			}
			if err := m.Upstream.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClientHistoryReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClientHistoryReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClientHistoryReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClientHistoryItem) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClientHistoryItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClientHistoryItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateTime", wireType)
			}
			m.DateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DateTime |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EventType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventResult", wireType)
			}
			m.EventResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EventResult |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ErrorCode |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstallSource", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstallSource = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClientHistoryResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClientHistoryResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClientHistoryResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &GetClientHistoryItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAppVersionsReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAppVersionsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAppVersionsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateStart", wireType)
			}
			m.DateStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DateStart |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnd", wireType)
			}
			m.DateEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DateEnd |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OEM", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OEM = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EventType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventResult", wireType)
			}
			m.EventResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EventResult |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppVersionItem) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppVersionItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppVersionItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Count = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListAppVersionsResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListAppVersionsResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListAppVersionsResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &AppVersionItem{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListClientUpdatesReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListClientUpdatesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListClientUpdatesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateStart", wireType)
			}
			m.DateStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DateStart |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnd", wireType)
			}
			m.DateEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DateEnd |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OEM", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OEM = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EventType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventResult", wireType)
			}
			m.EventResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EventResult |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Limit |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Skip", wireType)
			}
			m.Skip = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Skip |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ClientUpdate) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeen", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastSeen = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EventType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventResult", wireType)
			}
			m.EventResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EventResult |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ErrorCode |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OEM", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OEM = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ListClientUpdatesResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ListClientUpdatesResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ListClientUpdatesResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &ClientUpdate{})
			if err := m.Items[len(m.Items)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClientUpdateCountReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClientUpdateCountReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClientUpdateCountReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateStart", wireType)
			}
			m.DateStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DateStart |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DateEnd", wireType)
			}
			m.DateEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DateEnd |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OEM", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OEM = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventType", wireType)
			}
			m.EventType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EventType |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventResult", wireType)
			}
			m.EventResult = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EventResult |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetClientUpdateCountResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetClientUpdateCountResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetClientUpdateCountResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateUUIDReq) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateUUIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateUUIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerateUUIDResp) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerateUUIDResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerateUUIDResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UUID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UUID = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorApi = []byte{
	// 3984 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xec, 0x5c, 0xcb, 0x73, 0x1b, 0x47,
	0x73, 0x0f, 0x00, 0x3e, 0x80, 0xe6, 0x7b, 0xf8, 0x02, 0x57, 0x2f, 0x6a, 0xbf, 0xcf, 0xb2, 0x45,
	0x4b, 0x82, 0x85, 0x44, 0xb6, 0x44, 0x3f, 0x64, 0x91, 0x52, 0x24, 0x39, 0x92, 0x2c, 0x2f, 0x45,
	0xc5, 0x65, 0x27, 0x81, 0x21, 0x72, 0x4d, 0xa2, 0x04, 0x02, 0x30, 0x16, 0x90, 0xad, 0xa8, 0x58,
	0x95, 0xe4, 0xe2, 0x73, 0x2a, 0x97, 0x54, 0xe5, 0xe2, 0x8b, 0xcb, 0x49, 0x2a, 0xf1, 0xc9, 0xe5,
	0xbf, 0x21, 0xc7, 0x54, 0xe5, 0x98, 0x2a, 0x57, 0xca, 0x4e, 0x2e, 0x71, 0x6e, 0xbe, 0xe4, 0x98,
	0x9e, 0x9e, 0x99, 0x9d, 0x99, 0xdd, 0xc5, 0x8b, 0x14, 0x5d, 0xa9, 0xaf, 0x74, 0x10, 0x77, 0xb6,
	0x67, 0xb6, 0xbb, 0xa7, 0xbb, 0x67, 0xa6, 0x67, 0xe6, 0x07, 0x41, 0xae, 0xdc, 0xa8, 0x5c, 0x68,
	0x34, 0xeb, 0xad, 0x3a, 0x1b, 0x69, 0x37, 0xb6, 0xcb, 0x2d, 0xdf, 0x39, 0xbf, 0x53, 0x69, 0xed,
	0xb6, 0x1f, 0x5d, 0xd8, 0xaa, 0xef, 0x15, 0x76, 0xea, 0x3b, 0xf5, 0x02, 0x55, 0x3f, 0x6a, 0x7f,
	0x4a, 0x6f, 0xf4, 0x42, 0x25, 0xf1, 0x99, 0xf3, 0x81, 0xd9, 0xdc, 0xaf, 0x61, 0xfb, 0x9d, 0x66,
	0x63, 0xeb, 0xfc, 0x0e, 0xb2, 0xfa, 0xbc, 0xfc, 0xb4, 0xd0, 0xda, 0xad, 0x34, 0xb7, 0x4b, 0x8d,
	0x72, 0xb3, 0xf5, 0x14, 0xbf, 0xaa, 0xef, 0x54, 0x7d, 0x94, 0x18, 0xc8, 0x62, 0x01, 0xcb, 0x85,
	0x72, 0xad, 0x56, 0x6f, 0x95, 0x5b, 0x95, 0x7a, 0x2d, 0x10, 0x2c, 0xdd, 0x0f, 0x60, 0x68, 0x33,
	0xf0, 0x9b, 0xec, 0x15, 0xc8, 0xb6, 0xf1, 0x59, 0x2b, 0xef, 0xf9, 0xf9, 0xd4, 0x72, 0xea, 0x95,
	0xdc, 0xda, 0xf8, 0x7f, 0xff, 0x70, 0x2a, 0xa4, 0x79, 0x61, 0x89, 0x9d, 0x82, 0xe1, 0x56, 0xfd,
	0xb1, 0x5f, 0xcb, 0xa7, 0xa9, 0x59, 0x0e, 0x9b, 0x09, 0x82, 0x27, 0x1e, 0xee, 0xe7, 0x90, 0xb9,
	0xd6, 0x68, 0xb0, 0xe3, 0x90, 0xae, 0x6c, 0x2b, 0x5e, 0x3f, 0xfe, 0x70, 0x2a, 0x7d, 0xfb, 0x3a,
	0x36, 0x45, 0x9a, 0x87, 0xff, 0x38, 0x97, 0x6a, 0xf9, 0x91, 0x5f, 0x35, 0xb9, 0x10, 0xc1, 0x13,
	0x0f, 0x76, 0x11, 0xc6, 0xb6, 0xfd, 0x60, 0xab, 0x59, 0x69, 0x70, 0x75, 0xf3, 0x19, 0x6a, 0x36,
	0x85, 0xcd, 0x4c, 0xb2, 0x67, 0xbe, 0xb8, 0xdf, 0xa6, 0x61, 0x74, 0x7d, 0x17, 0xfb, 0x88, 0x9f,
	0x77, 0x97, 0x7e, 0x16, 0x46, 0xca, 0x8d, 0x46, 0x09, 0x5b, 0x08, 0xf1, 0x0c, 0x5b, 0x0c, 0xa3,
	0xd2, 0xd4, 0x68, 0xb8, 0xcc, 0x0b, 0x1e, 0x3d, 0x0c, 0x45, 0x33, 0x1d, 0x14, 0x7d, 0x09, 0x46,
	0x9f, 0xf8, 0xcd, 0x80, 0x2b, 0x39, 0x44, 0x4d, 0xc6, 0xb0, 0x89, 0x22, 0x79, 0xaa, 0xc0, 0x9b,
	0x35, 0xda, 0x8f, 0xaa, 0x95, 0x60, 0x37, 0x3f, 0x8c, 0xcd, 0xb2, 0xa2, 0x99, 0x24, 0x79, 0xaa,
	0xc0, 0xde, 0x86, 0xb1, 0x76, 0x23, 0x68, 0x35, 0xfd, 0xf2, 0x1e, 0x57, 0x6f, 0x84, 0x38, 0x1e,
	0x47, 0xf5, 0x60, 0x53, 0x92, 0x49, 0x47, 0x68, 0x87, 0x6f, 0x9e, 0x2e, 0x6f, 0xb3, 0x73, 0x00,
	0x5b, 0x58, 0x6c, 0xf9, 0xdb, 0xa5, 0x72, 0x2b, 0x3f, 0x4a, 0x5f, 0x4f, 0x60, 0xfb, 0x9c, 0xa4,
	0x5e, 0x6b, 0x79, 0xba, 0xe8, 0xfe, 0x94, 0x81, 0xe1, 0x9b, 0xcd, 0x7a, 0xbb, 0xc1, 0x5e, 0x86,
	0xec, 0x0e, 0x2f, 0x94, 0x3a, 0x18, 0x6d, 0x94, 0x6a, 0x6f, 0x0f, 0x64, 0xb9, 0x2b, 0xa8, 0x8b,
	0xf0, 0x06, 0x6f, 0x2e, 0xcc, 0xe7, 0x60, 0xf3, 0x9c, 0xf4, 0x11, 0x7d, 0x92, 0xdb, 0x52, 0x2f,
	0x5e, 0x58, 0x34, 0x8c, 0x3e, 0xd4, 0xc1, 0xe8, 0x45, 0x18, 0x17, 0x43, 0xa8, 0xb4, 0x55, 0x6f,
	0xd7, 0x5a, 0x64, 0xd2, 0x8c, 0x08, 0x0f, 0x41, 0x5f, 0xe7, 0x64, 0xcf, 0x7c, 0x61, 0x6f, 0xc2,
	0x94, 0xfc, 0xa6, 0x52, 0x6b, 0xf9, 0xcd, 0x27, 0xe5, 0x2a, 0x99, 0x37, 0xb3, 0xc6, 0xf0, 0xb3,
	0x49, 0x51, 0x75, 0x5b, 0xd6, 0x78, 0x91, 0x77, 0x76, 0x19, 0x24, 0x25, 0xc0, 0x01, 0x86, 0x63,
	0x61, 0x9b, 0x8c, 0x9b, 0x5d, 0x9b, 0xc1, 0x6f, 0x27, 0x64, 0xcd, 0x7d, 0xaa, 0xf0, 0xec, 0x57,
	0xfd, 0x65, 0xa9, 0x51, 0xaf, 0x57, 0x2b, 0xb5, 0x9d, 0x7c, 0x36, 0xfa, 0xe5, 0x7d, 0x51, 0xe1,
	0xd9, 0xaf, 0xec, 0x06, 0x4c, 0xd4, 0xfd, 0xbd, 0xd2, 0xa3, 0x6a, 0x79, 0xeb, 0x31, 0x06, 0x47,
	0x2b, 0x9f, 0x23, 0x6b, 0x2c, 0xa3, 0x0d, 0xc7, 0xdf, 0xbf, 0x71, 0x77, 0x4d, 0xd1, 0x91, 0xd1,
	0x38, 0x36, 0x0c, 0xdf, 0x3d, 0xeb, 0xcd, 0xfd, 0x72, 0x08, 0x46, 0xef, 0xe3, 0x4b, 0x79, 0xc7,
	0x37, 0xdc, 0x97, 0xea, 0xe5, 0x3e, 0x23, 0xae, 0xd3, 0x5d, 0xe2, 0x7a, 0x19, 0x32, 0xed, 0xa6,
	0x1a, 0x1d, 0x93, 0xc8, 0x2e, 0xb3, 0xe9, 0xdd, 0xc1, 0x96, 0x9c, 0xea, 0xf1, 0x3f, 0x38, 0x14,
	0x87, 0x82, 0xca, 0x9f, 0xfb, 0xd2, 0x97, 0x59, 0xac, 0xa3, 0x77, 0x8f, 0xfe, 0xb2, 0x33, 0x90,
	0x0d, 0x76, 0xcb, 0x17, 0x4b, 0x41, 0x7b, 0x8f, 0xbc, 0x28, 0xe5, 0x70, 0xda, 0x46, 0x7b, 0xcf,
	0x53, 0x05, 0x1e, 0xd9, 0x58, 0x2c, 0x5e, 0x7a, 0x9d, 0x5a, 0x8e, 0xe8, 0xc8, 0x16, 0x54, 0xde,
	0x56, 0x17, 0xf9, 0x74, 0xd6, 0xf4, 0x3f, 0x6b, 0x57, 0x9a, 0xa1, 0xa3, 0x68, 0x3a, 0x53, 0x34,
	0x2f, 0x2c, 0xb1, 0x7b, 0xb0, 0xb0, 0xe7, 0xb7, 0xca, 0x68, 0xf7, 0x72, 0x29, 0xa8, 0xec, 0xd4,
	0xca, 0xad, 0x76, 0xd3, 0x2f, 0x35, 0x83, 0x32, 0xb9, 0x29, 0xb7, 0x96, 0xc7, 0xef, 0xe6, 0x54,
	0x8b, 0x0d, 0xd5, 0xc0, 0x0b, 0xca, 0x5e, 0x22, 0x95, 0x5d, 0x82, 0x09, 0x83, 0x1f, 0x76, 0x5b,
	0x38, 0x6d, 0x9a, 0x3b, 0x49, 0x7f, 0x80, 0xdd, 0xb7, 0xde, 0x22, 0x03, 0x17, 0xba, 0x0f, 0x5c,
	0x2e, 0xa4, 0xe9, 0xe3, 0xf4, 0x1e, 0xf8, 0x25, 0x9c, 0xd0, 0xfd, 0x20, 0x3f, 0xa6, 0x85, 0xc8,
	0x8a, 0x7b, 0x9c, 0xee, 0x59, 0x6f, 0xee, 0x63, 0xc8, 0xaa, 0x59, 0xa4, 0xc7, 0x04, 0x29, 0xbd,
	0x9a, 0xee, 0xec, 0xd5, 0x5e, 0xf3, 0xa2, 0x7b, 0x05, 0x26, 0xd6, 0x49, 0x61, 0xbe, 0xbe, 0x78,
	0xfe, 0x67, 0xfd, 0x2f, 0x31, 0xee, 0x5b, 0x30, 0x69, 0x7e, 0x1a, 0x34, 0xd8, 0x0a, 0x0c, 0xf1,
	0x5a, 0xfa, 0x6e, 0xac, 0x38, 0x7e, 0x41, 0x0c, 0x94, 0x0b, 0xbc, 0x5e, 0x44, 0x14, 0xaf, 0xf5,
	0xe8, 0xaf, 0x3b, 0x09, 0xe3, 0x77, 0x30, 0xee, 0x79, 0x5d, 0x80, 0x72, 0xdd, 0x77, 0x60, 0xc2,
	0x78, 0x47, 0x66, 0xe7, 0x61, 0xb8, 0xd2, 0xf2, 0xf7, 0x02, 0xe4, 0x96, 0x89, 0x71, 0xa3, 0x8e,
	0xb4, 0xa9, 0xad, 0x68, 0xe5, 0xbe, 0x0e, 0x70, 0xd3, 0x6f, 0x0d, 0xde, 0x8b, 0x2b, 0x30, 0x16,
	0x7e, 0x37, 0x60, 0x17, 0xd0, 0x76, 0xd7, 0xd1, 0x71, 0x07, 0xb1, 0xdd, 0x34, 0x4c, 0x9a, 0x9f,
	0x06, 0x0d, 0xf7, 0x5d, 0x98, 0xbb, 0xe9, 0xd7, 0xfc, 0xa6, 0xb4, 0xe7, 0x03, 0x5a, 0xab, 0x07,
	0xe2, 0xb9, 0x0e, 0xf3, 0x09, 0x1c, 0x06, 0xec, 0xd3, 0x5f, 0xa4, 0x60, 0x5c, 0x78, 0x15, 0xe7,
	0x1b, 0x2e, 0xff, 0xd7, 0x4f, 0x10, 0xde, 0x50, 0x21, 0x49, 0x1a, 0xa0, 0xfe, 0x67, 0x20, 0x83,
	0x93, 0x9d, 0x54, 0x7f, 0x4c, 0xa9, 0x8f, 0xb5, 0x6b, 0xa3, 0x3c, 0xd8, 0xb1, 0xce, 0xe3, 0x7f,
	0xdc, 0x09, 0x18, 0xe3, 0x21, 0x84, 0x15, 0x14, 0x51, 0x6f, 0x89, 0x08, 0x13, 0xaf, 0xc8, 0xe6,
	0x9c, 0x1d, 0x50, 0x16, 0x23, 0x52, 0x9c, 0x6a, 0x55, 0x3c, 0x9d, 0x85, 0x1c, 0xc6, 0x45, 0x3f,
	0x46, 0x70, 0xff, 0x80, 0x42, 0x6f, 0x50, 0x6d, 0xcf, 0xc1, 0xb8, 0x08, 0x81, 0xbe, 0x64, 0x4c,
	0xa9, 0x58, 0x93, 0x62, 0xdc, 0xf7, 0x61, 0x72, 0x83, 0x84, 0xde, 0x21, 0x73, 0x1f, 0xda, 0x53,
	0x18, 0xcd, 0x53, 0x16, 0xc3, 0x01, 0xba, 0xb2, 0x03, 0x73, 0xe2, 0xd3, 0xeb, 0x86, 0x4f, 0x7b,
	0x6a, 0x14, 0x09, 0x8d, 0x74, 0x1f, 0xa1, 0x71, 0x15, 0xe6, 0x13, 0x04, 0x0d, 0xa0, 0xe9, 0xcf,
	0x29, 0x98, 0x16, 0xc1, 0x25, 0xd3, 0x1b, 0xae, 0x66, 0x68, 0x9a, 0x54, 0x87, 0x20, 0x1e, 0x20,
	0x9d, 0x32, 0xd6, 0xe3, 0x4c, 0x7f, 0x79, 0xe6, 0x50, 0xff, 0x79, 0xe6, 0xf0, 0x60, 0x79, 0xa6,
	0xfb, 0x47, 0x30, 0x13, 0xe9, 0x2c, 0x9a, 0xea, 0x75, 0x18, 0x95, 0x29, 0x9c, 0x34, 0xd7, 0x94,
	0x32, 0x97, 0x6c, 0x25, 0x74, 0x91, 0x6d, 0x3c, 0x55, 0xc0, 0xe1, 0x34, 0xc5, 0x87, 0x93, 0x6c,
	0xc4, 0x47, 0xd8, 0x00, 0x79, 0x8a, 0x7b, 0x1d, 0xa6, 0xed, 0xaf, 0x51, 0x93, 0xd7, 0xec, 0x01,
	0x19, 0xd3, 0x23, 0x3e, 0x28, 0xdf, 0x84, 0x09, 0x1c, 0x69, 0x86, 0xeb, 0x56, 0x8c, 0x08, 0xeb,
	0x96, 0xb5, 0xf2, 0x21, 0x74, 0x0b, 0x26, 0xcd, 0x8f, 0x0f, 0x61, 0x8a, 0x77, 0x60, 0x5a, 0x0c,
	0xc6, 0x03, 0x6a, 0x32, 0x0b, 0x33, 0x91, 0xef, 0x71, 0x40, 0x6f, 0x00, 0xdb, 0x08, 0xd5, 0x7b,
	0x5e, 0x83, 0xfa, 0x2e, 0xcc, 0xc6, 0x98, 0x1e, 0xa2, 0xe3, 0x1f, 0xd3, 0x40, 0x97, 0x6d, 0x1e,
	0xca, 0xa0, 0xee, 0xa9, 0x65, 0x7f, 0x39, 0x2a, 0xce, 0x68, 0xf3, 0x09, 0xcc, 0x9f, 0x97, 0xb6,
	0xf7, 0xe5, 0xd8, 0xea, 0x47, 0x5b, 0x35, 0x34, 0xd3, 0x9d, 0x87, 0xa6, 0xad, 0x6d, 0xc8, 0xfc,
	0x10, 0xda, 0x7e, 0x6a, 0x32, 0x54, 0xc3, 0xbb, 0xb7, 0xba, 0x05, 0x7b, 0x8a, 0x90, 0xb9, 0x60,
	0x97, 0x49, 0xe1, 0x3e, 0x2c, 0x24, 0xc9, 0x39, 0x84, 0xe6, 0x97, 0x21, 0x6f, 0x85, 0x73, 0xdf,
	0xca, 0x63, 0xcc, 0x2f, 0x75, 0xf8, 0xf2, 0x10, 0xea, 0xfc, 0x4f, 0x46, 0x25, 0xa6, 0xb4, 0x6b,
	0xe6, 0x5a, 0xbc, 0xd8, 0x38, 0xff, 0xee, 0x6e, 0x9c, 0xaf, 0xc1, 0x94, 0xe5, 0x6d, 0x8c, 0x9c,
	0x0b, 0x30, 0x4c, 0x0e, 0x95, 0x71, 0x33, 0xa1, 0xe2, 0x86, 0x5a, 0x08, 0x73, 0x53, 0xbd, 0x27,
	0x1e, 0xee, 0xaa, 0xd8, 0x7b, 0x50, 0xf5, 0xa0, 0x0b, 0xdb, 0xbb, 0x30, 0x69, 0x7e, 0x2b, 0xa4,
	0x9b, 0xcb, 0x5a, 0x92, 0x74, 0x6b, 0x51, 0x2b, 0xd3, 0x0e, 0xe4, 0x28, 0x63, 0x15, 0x17, 0xac,
	0x71, 0x2d, 0xe2, 0x00, 0x06, 0xda, 0x56, 0xdb, 0x95, 0x23, 0xd5, 0x72, 0x06, 0xa6, 0x2c, 0x29,
	0xb8, 0x28, 0x7e, 0x9d, 0xa2, 0x39, 0x9c, 0x08, 0xe1, 0xb8, 0xfa, 0xff, 0x37, 0xa2, 0xdd, 0x9b,
	0x34, 0x79, 0x47, 0xd5, 0x3c, 0x80, 0xa5, 0xbf, 0xc4, 0x04, 0x55, 0x71, 0x0a, 0x93, 0x80, 0xa3,
	0xe8, 0x6c, 0xcf, 0x93, 0x81, 0x75, 0x98, 0x89, 0x28, 0x72, 0x80, 0xee, 0x7c, 0x95, 0xa2, 0xd5,
	0x86, 0xaa, 0x37, 0x8d, 0x99, 0xeb, 0x88, 0x3a, 0x15, 0x9d, 0x37, 0x33, 0xbd, 0xe7, 0x4d, 0xf7,
	0x36, 0x2c, 0x26, 0x6a, 0x78, 0x80, 0xde, 0xfe, 0x53, 0x0a, 0x96, 0x6c, 0x5e, 0xe1, 0x84, 0x7b,
	0x44, 0x1d, 0x4e, 0x98, 0xf4, 0x33, 0xfd, 0x4e, 0xfa, 0xee, 0x1d, 0x70, 0x3a, 0x69, 0x7b, 0x80,
	0xce, 0xff, 0x73, 0x0a, 0x4e, 0xd8, 0xec, 0xe4, 0x12, 0xb1, 0xd1, 0xc2, 0xf2, 0x51, 0x19, 0x20,
	0xbe, 0x70, 0x65, 0xfa, 0x5b, 0xb8, 0x30, 0x0f, 0x3a, 0xd9, 0x4d, 0xdd, 0x03, 0x58, 0xe0, 0xef,
	0x53, 0x90, 0xb7, 0x59, 0xaa, 0x95, 0xef, 0xa8, 0x3b, 0x1f, 0xae, 0xbd, 0x99, 0xfe, 0xd6, 0x5e,
	0xdc, 0x19, 0x2e, 0x75, 0xd0, 0xf4, 0x00, 0xfd, 0xfe, 0x2e, 0xa5, 0x87, 0x90, 0xb9, 0x70, 0x1f,
	0x55, 0xb7, 0x63, 0x89, 0x43, 0xe6, 0x40, 0x89, 0xc3, 0x7b, 0xda, 0x5b, 0xb6, 0xd6, 0x07, 0x30,
	0xc1, 0x16, 0xcc, 0xaa, 0xa5, 0xb1, 0xed, 0x07, 0xad, 0xe0, 0x61, 0xb9, 0x8a, 0x4f, 0xf6, 0x2a,
	0xe4, 0x5a, 0x95, 0x3d, 0x24, 0x94, 0xf7, 0x04, 0xab, 0x8c, 0x38, 0x2e, 0x0e, 0x89, 0x9e, 0x2e,
	0xf2, 0x19, 0x59, 0xcc, 0x5a, 0x69, 0x6a, 0x48, 0x42, 0x88, 0xe0, 0x89, 0x87, 0xfb, 0x0f, 0x69,
	0x58, 0x52, 0xcb, 0xb8, 0xdc, 0x1f, 0x05, 0x5e, 0xbd, 0x5a, 0x15, 0x2b, 0xf2, 0x00, 0x97, 0x06,
	0x17, 0x0d, 0xa7, 0x08, 0x6b, 0x2f, 0x60, 0xe3, 0x51, 0x62, 0x4c, 0xcd, 0xa5, 0x57, 0xae, 0x6b,
	0xf7, 0x9c, 0x03, 0xa0, 0x40, 0x43, 0x55, 0x9b, 0x6a, 0x5e, 0xa5, 0xae, 0x70, 0xea, 0x06, 0x27,
	0x7a, 0xba, 0xc8, 0xaf, 0x0b, 0xa8, 0xb5, 0x5f, 0xdb, 0xa6, 0x1c, 0x37, 0x23, 0x52, 0x75, 0x4e,
	0xbb, 0x51, 0x43, 0xa7, 0xcb, 0x02, 0x9a, 0x19, 0x9a, 0x7e, 0x50, 0xaf, 0xb6, 0xe9, 0x04, 0x48,
	0x64, 0xb9, 0xb4, 0x77, 0xd1, 0x54, 0xcf, 0x28, 0xf3, 0xc3, 0x50, 0xb9, 0x5b, 0x0c, 0xe4, 0xe5,
	0x02, 0x1d, 0x86, 0x2a, 0x9a, 0x17, 0x96, 0xdc, 0x67, 0x30, 0x63, 0xd9, 0xe9, 0x36, 0xa6, 0x5a,
	0xe6, 0x46, 0x34, 0xd5, 0xe5, 0x70, 0xe6, 0x2a, 0x8c, 0x3c, 0x21, 0xff, 0xa1, 0xee, 0x3c, 0x83,
	0x3b, 0x66, 0x79, 0xdf, 0x76, 0xf1, 0x1a, 0x20, 0x0b, 0xd9, 0xdc, 0x93, 0x4f, 0xf7, 0x43, 0x70,
	0x3a, 0xf9, 0x09, 0x63, 0x6b, 0xd5, 0xce, 0x0f, 0x97, 0x2c, 0xee, 0xa6, 0xbe, 0x09, 0xb9, 0xe2,
	0x37, 0x69, 0x58, 0x54, 0xac, 0x6f, 0x3c, 0xf1, 0x6b, 0xad, 0x17, 0x01, 0xd0, 0x21, 0x00, 0xfe,
	0x3d, 0x05, 0x53, 0x86, 0x99, 0x06, 0xf1, 0x3f, 0x76, 0xd5, 0xe7, 0x1f, 0x95, 0x5a, 0x4f, 0x1b,
	0xbe, 0x1c, 0x8d, 0xd4, 0x55, 0xa2, 0x3e, 0x40, 0xa2, 0xa7, 0x8b, 0x3c, 0xe7, 0x10, 0xad, 0x51,
	0xcd, 0x76, 0xd5, 0xca, 0x39, 0x88, 0xee, 0x11, 0xd9, 0x33, 0x5f, 0x0e, 0x1f, 0x61, 0x0f, 0x20,
	0x9f, 0x1c, 0x06, 0x18, 0x5f, 0x97, 0xed, 0xf8, 0x5a, 0xb4, 0x78, 0x6b, 0x6b, 0x24, 0x44, 0xd7,
	0x8f, 0x19, 0x75, 0x3a, 0x2a, 0x6f, 0x22, 0x07, 0x0c, 0xab, 0x17, 0x97, 0x91, 0xbf, 0xe6, 0x65,
	0x64, 0xec, 0x7a, 0x11, 0xfa, 0xba, 0x5e, 0x0c, 0x0f, 0x85, 0x43, 0x1f, 0x8b, 0xb3, 0x96, 0x86,
	0x78, 0x8d, 0x9e, 0xb5, 0xc8, 0x56, 0xf2, 0x14, 0x4c, 0x7e, 0xa2, 0x0a, 0x38, 0xcd, 0xd2, 0xa1,
	0xb0, 0x6c, 0x34, 0xe0, 0xde, 0x99, 0xf6, 0x20, 0x95, 0xbd, 0x8a, 0xb5, 0xe2, 0x11, 0xc1, 0x13,
	0x0f, 0x8a, 0x83, 0xc7, 0x95, 0x86, 0x1c, 0x53, 0x22, 0x0e, 0xf0, 0xdd, 0xa3, 0xbf, 0xae, 0x2f,
	0xce, 0x94, 0xb5, 0xf0, 0x2e, 0x67, 0xca, 0xaa, 0x1b, 0xb1, 0xa0, 0x17, 0x48, 0x99, 0x56, 0xb9,
	0x6a, 0x2a, 0x41, 0x04, 0x4f, 0x3c, 0x70, 0x7f, 0xce, 0x0f, 0x9d, 0x8f, 0x72, 0x44, 0xc8, 0xa3,
	0xe9, 0xe7, 0xe1, 0x90, 0x6d, 0x75, 0x34, 0x7d, 0xa4, 0xfa, 0x86, 0x07, 0xd8, 0x86, 0xca, 0xee,
	0x43, 0x15, 0x58, 0xe6, 0xf9, 0x9f, 0x1c, 0xeb, 0xa9, 0x3e, 0xae, 0xa8, 0x3b, 0x9d, 0x61, 0xdf,
	0x07, 0x16, 0xe5, 0x4b, 0xab, 0x68, 0x56, 0x1d, 0x6a, 0x4a, 0x0b, 0x4d, 0x87, 0x17, 0x9b, 0x92,
	0x2e, 0x6f, 0x4a, 0xd5, 0x57, 0x61, 0xc9, 0x65, 0x22, 0x70, 0x54, 0x3b, 0xba, 0x2d, 0xfc, 0x43,
	0x98, 0x89, 0xd0, 0x50, 0xc8, 0x45, 0x3b, 0x9a, 0xe2, 0x12, 0xe2, 0x73, 0xe8, 0x05, 0x72, 0x65,
	0xff, 0x47, 0xa0, 0x77, 0x71, 0x99, 0x32, 0xdb, 0x1f, 0xb2, 0x6b, 0x17, 0x95, 0x67, 0xfa, 0xd7,
	0x60, 0x0e, 0x58, 0xf4, 0x13, 0xf4, 0x26, 0xda, 0x68, 0xe3, 0x69, 0x6d, 0xcb, 0xb2, 0xd1, 0xc7,
	0x30, 0x13, 0xa1, 0xa1, 0xb6, 0x2e, 0x8c, 0x60, 0x4e, 0xd0, 0x6a, 0x07, 0x52, 0x00, 0x2d, 0x57,
	0x82, 0xe2, 0xc9, 0x27, 0x6f, 0xb3, 0x8d, 0x53, 0x57, 0x45, 0x39, 0x99, 0xda, 0x08, 0x8a, 0x27,
	0x9f, 0xee, 0x06, 0x9d, 0x37, 0x28, 0xde, 0x18, 0x25, 0xbd, 0xcf, 0xbe, 0x7b, 0xe2, 0x1f, 0x78,
	0xec, 0x44, 0x99, 0x1e, 0xd2, 0xc0, 0x0f, 0xe8, 0x46, 0x45, 0x35, 0x7b, 0x5e, 0xf7, 0x34, 0x1e,
	0x1d, 0x73, 0x45, 0xb8, 0x1e, 0x52, 0xd3, 0x3b, 0xb8, 0x27, 0xf1, 0x5b, 0xeb, 0xd5, 0x0a, 0xae,
	0xf8, 0xb7, 0x30, 0xb4, 0xeb, 0xcd, 0xa7, 0x5c, 0xd3, 0x4b, 0x90, 0xdb, 0x22, 0x9a, 0x9e, 0x10,
	0xf2, 0xa8, 0x70, 0x56, 0x34, 0x24, 0xb5, 0xb3, 0x5b, 0xb2, 0xec, 0xa9, 0xd2, 0xb6, 0xfb, 0x5f,
	0x69, 0x0e, 0x50, 0xb0, 0xd9, 0x51, 0x52, 0x75, 0x16, 0x28, 0xef, 0x2b, 0xf1, 0x8d, 0x8c, 0xdc,
	0xe3, 0x90, 0x46, 0x9c, 0xf8, 0xa0, 0xc2, 0x11, 0x0a, 0xaa, 0xf4, 0x2b, 0x24, 0x56, 0x5c, 0x42,
	0xb3, 0x59, 0x6f, 0x96, 0xb6, 0xea, 0xdb, 0xbe, 0xcc, 0x3c, 0x85, 0x04, 0x4e, 0x5d, 0x47, 0xa2,
	0xa7, 0x8b, 0xe6, 0x6c, 0x37, 0xdc, 0x25, 0x5f, 0x31, 0xb3, 0xe5, 0x91, 0xfe, 0xb2, 0x65, 0xdc,
	0x99, 0x57, 0x6a, 0x18, 0xfc, 0xd5, 0x6a, 0x29, 0xa8, 0xb7, 0x9b, 0x5b, 0xbe, 0x44, 0xf9, 0xd1,
	0xce, 0x5c, 0xd6, 0x6c, 0x50, 0x85, 0x67, 0xbf, 0xba, 0x9b, 0x71, 0x33, 0x53, 0x24, 0xbc, 0x6d,
	0x4f, 0x45, 0xc7, 0xc3, 0xac, 0x2e, 0xc1, 0x27, 0x09, 0xd3, 0xd2, 0x2f, 0x69, 0x60, 0x12, 0x0d,
	0x11, 0x6e, 0x49, 0x30, 0x18, 0xec, 0xac, 0x3e, 0x35, 0x40, 0x56, 0x9f, 0xee, 0x92, 0xd5, 0xeb,
	0x05, 0x27, 0x33, 0xc8, 0x4e, 0x64, 0xa8, 0x3f, 0xdb, 0xf6, 0xe9, 0x35, 0x9c, 0x1c, 0x70, 0xbb,
	0x2f, 0x1d, 0x46, 0x93, 0x03, 0xee, 0xf2, 0xf9, 0xe4, 0x80, 0x54, 0x8f, 0xff, 0x89, 0x84, 0xe3,
	0xe8, 0x80, 0xe1, 0x98, 0xed, 0x1d, 0x8e, 0xee, 0xf7, 0x29, 0x98, 0xd4, 0x16, 0x97, 0xc3, 0xe5,
	0x28, 0x77, 0x69, 0x7d, 0xc2, 0x0f, 0xc2, 0xa3, 0x06, 0xe3, 0x02, 0xca, 0x3a, 0x6a, 0xb8, 0x07,
	0xb3, 0xb1, 0x68, 0xc1, 0x20, 0x7c, 0xc3, 0x0e, 0xc2, 0x05, 0x03, 0x68, 0x61, 0xf4, 0x31, 0x21,
	0xfc, 0x7e, 0xce, 0xc0, 0x1c, 0xdd, 0xff, 0x53, 0xa8, 0xca, 0xf3, 0xb6, 0x17, 0x01, 0x78, 0xd4,
	0x01, 0x68, 0x4f, 0xf6, 0xb9, 0x7e, 0x27, 0x7b, 0x9d, 0x98, 0x43, 0x8f, 0xc4, 0x7c, 0x2c, 0x31,
	0x31, 0xff, 0x26, 0x03, 0xe3, 0xa6, 0xa7, 0x07, 0x09, 0x7a, 0x4b, 0xe3, 0x74, 0xdf, 0x1a, 0x9b,
	0x6e, 0xcc, 0x0c, 0xec, 0xc6, 0x6e, 0x90, 0x70, 0x5c, 0xdf, 0xaa, 0xe5, 0xa0, 0x55, 0x0a, 0x7c,
	0x5f, 0xf9, 0x9b, 0xd6, 0x37, 0x4e, 0xdc, 0x40, 0x9a, 0x17, 0x96, 0x22, 0xfe, 0x1c, 0x19, 0xd0,
	0x9f, 0xa3, 0x03, 0xaf, 0x6f, 0xd9, 0x1e, 0xeb, 0x9b, 0x8c, 0xc0, 0x5c, 0xc7, 0x08, 0xc4, 0x71,
	0x3e, 0x9f, 0x30, 0x2c, 0x71, 0xa4, 0x5f, 0xb2, 0x47, 0xfa, 0x5c, 0x78, 0xf5, 0x6e, 0xb4, 0x4c,
	0x18, 0xe7, 0xff, 0x2b, 0xce, 0xa7, 0xcc, 0x56, 0xe1, 0x85, 0xcf, 0x8b, 0xa1, 0x7e, 0xa4, 0x6b,
	0xcd, 0x9b, 0x74, 0x24, 0x94, 0x60, 0xf9, 0xc0, 0x38, 0x5a, 0x4e, 0x75, 0x38, 0x5a, 0x9e, 0xe1,
	0xbb, 0x10, 0x89, 0x1d, 0xdd, 0xa4, 0x1b, 0x56, 0xf7, 0x32, 0x4c, 0xdb, 0x24, 0xe4, 0xf3, 0x5b,
	0x18, 0x6a, 0xb7, 0xc3, 0x51, 0x3c, 0x8d, 0x1d, 0x1d, 0xe2, 0x75, 0x84, 0x21, 0x45, 0xba, 0x47,
	0x7f, 0x8b, 0xbf, 0xac, 0xc0, 0x84, 0xd0, 0x60, 0xc3, 0x6f, 0x3e, 0xa9, 0x6c, 0xf9, 0xec, 0x1e,
	0x80, 0x86, 0x0a, 0xb3, 0xf9, 0x30, 0x98, 0x4c, 0xe4, 0xb1, 0xb3, 0x90, 0x44, 0xc6, 0x9d, 0xc8,
	0xcc, 0x5f, 0xfd, 0xdb, 0x7f, 0xfe, 0x4d, 0x7a, 0xcc, 0x1d, 0x29, 0x10, 0xe0, 0x77, 0x35, 0xb5,
	0xc2, 0x6e, 0x41, 0x2e, 0x04, 0x0b, 0xb3, 0x30, 0x36, 0x4d, 0x3c, 0xb1, 0x33, 0x9f, 0x40, 0x45,
	0x66, 0x93, 0xc4, 0x2c, 0xcb, 0x24, 0x33, 0x76, 0x17, 0x46, 0x25, 0xfc, 0x97, 0x31, 0x23, 0xa5,
	0x52, 0x3a, 0xcd, 0xc6, 0x68, 0xc8, 0x63, 0x89, 0x78, 0xcc, 0xb2, 0x19, 0xc1, 0xa3, 0xf0, 0x4c,
	0x41, 0x70, 0xf7, 0xd9, 0x43, 0x00, 0x8d, 0xeb, 0xd5, 0x1d, 0xb5, 0x60, 0xc2, 0xba, 0xa3, 0x11,
	0x08, 0xb0, 0xe4, 0xbb, 0x92, 0xc0, 0xf7, 0x0b, 0x98, 0x89, 0x61, 0x7b, 0x99, 0x91, 0x03, 0xc6,
	0x81, 0xc3, 0xce, 0x89, 0x2e, 0xb5, 0x28, 0xec, 0x0c, 0x09, 0x5b, 0x76, 0x8e, 0xc5, 0x84, 0x15,
	0xe8, 0x07, 0x42, 0x85, 0x9a, 0xff, 0x39, 0x37, 0xf5, 0x7b, 0x90, 0x0b, 0xd1, 0xb8, 0xda, 0xd4,
	0x26, 0x44, 0xd8, 0x99, 0x4f, 0xa0, 0xa2, 0x84, 0x69, 0x92, 0x00, 0xee, 0x70, 0x01, 0x87, 0x1f,
	0xb9, 0xed, 0x3a, 0x64, 0x15, 0x22, 0x97, 0xcd, 0x9a, 0xfe, 0x91, 0x90, 0x5d, 0x67, 0x2e, 0x4e,
	0x44, 0x46, 0x13, 0xc4, 0x68, 0x94, 0x09, 0x46, 0x6c, 0x1d, 0x46, 0x04, 0xdc, 0x96, 0xcd, 0x18,
	0xde, 0x91, 0xba, 0xb0, 0x28, 0x89, 0x6f, 0x65, 0xe9, 0xfb, 0x71, 0x06, 0xf4, 0x7d, 0xe1, 0x59,
	0x65, 0x7b, 0x9f, 0xdd, 0x81, 0x5c, 0x88, 0xa7, 0xd5, 0xdd, 0x32, 0x01, 0xb9, 0xce, 0x7c, 0x02,
	0x55, 0x73, 0x5b, 0x31, 0xb9, 0x95, 0x60, 0xcc, 0xc0, 0xce, 0xb2, 0xd0, 0xc1, 0x36, 0x42, 0xd7,
	0x59, 0x4c, 0xa4, 0x23, 0xcf, 0x53, 0xc4, 0x73, 0xa9, 0x38, 0xad, 0x79, 0x16, 0x68, 0x63, 0xb8,
	0x2a, 0x01, 0x41, 0xfb, 0xb4, 0x39, 0xb6, 0x81, 0xaf, 0xda, 0xff, 0x49, 0xe0, 0x5b, 0xed, 0xff,
	0x44, 0xc4, 0xac, 0xfb, 0x2a, 0x89, 0x7c, 0xa9, 0xb8, 0x60, 0x88, 0x34, 0xa0, 0xb6, 0xab, 0x26,
	0xee, 0x96, 0x7d, 0xa4, 0x20, 0xd9, 0xea, 0x87, 0x5b, 0x79, 0xdb, 0xe5, 0x1a, 0x07, 0xe9, 0x2c,
	0x75, 0xa8, 0x41, 0x91, 0x73, 0x24, 0x72, 0xd2, 0xcd, 0x15, 0x24, 0x70, 0x82, 0x82, 0xe2, 0x91,
	0x80, 0x69, 0x2b, 0x64, 0x28, 0x5b, 0x34, 0x63, 0xc0, 0x40, 0x9b, 0x3a, 0xf9, 0xe4, 0x0a, 0x6d,
	0x3e, 0xb6, 0x18, 0x32, 0x96, 0x9d, 0x12, 0x2b, 0xc3, 0x3e, 0xdb, 0x20, 0x84, 0xb6, 0x52, 0x7e,
	0xde, 0xdc, 0x3b, 0x69, 0xcd, 0x17, 0x92, 0xc8, 0xc8, 0x7d, 0x81, 0xb8, 0x4f, 0xb3, 0x49, 0xcd,
	0x9d, 0x9c, 0xfe, 0x27, 0x0a, 0x92, 0x1d, 0x33, 0x4a, 0x14, 0x1c, 0xaa, 0x8d, 0x12, 0x87, 0x7d,
	0x4a, 0xee, 0x2b, 0x51, 0xee, 0x75, 0x82, 0x63, 0x9b, 0xc8, 0x4d, 0xe6, 0x18, 0x1e, 0x8d, 0xe0,
	0x44, 0x9d, 0x63, 0x1d, 0xeb, 0x50, 0xc6, 0x6f, 0x48, 0xc6, 0x89, 0xe2, 0x9c, 0x2d, 0xc3, 0x0e,
	0xb1, 0xa7, 0x14, 0x62, 0x36, 0xfc, 0xd2, 0x0a, 0xb1, 0x18, 0xec, 0xd3, 0x0a, 0xb1, 0x38, 0x6e,
	0xd3, 0x7d, 0x99, 0xc4, 0x9e, 0xc6, 0x10, 0xb3, 0xc5, 0xca, 0x55, 0x73, 0x35, 0x5c, 0x3e, 0xf7,
	0x4d, 0x94, 0xaa, 0xc4, 0x52, 0xfa, 0xdb, 0x49, 0xc2, 0x35, 0x8a, 0x33, 0x49, 0xb8, 0x01, 0xc3,
	0x74, 0xcf, 0x92, 0xf0, 0xdf, 0x14, 0xf3, 0x11, 0xe1, 0x0d, 0xc5, 0x7e, 0x35, 0x44, 0x59, 0xff,
	0x65, 0xca, 0x84, 0xde, 0x86, 0xbf, 0xbd, 0x49, 0x10, 0x60, 0x1c, 0xaa, 0x39, 0x27, 0xbb, 0x55,
	0xa3, 0x02, 0xe7, 0x48, 0x81, 0x33, 0xc5, 0xc5, 0x88, 0x02, 0xea, 0x7c, 0x66, 0xd5, 0xc4, 0x6d,
	0xa2, 0x09, 0xe6, 0x13, 0x91, 0x90, 0x6c, 0x39, 0x31, 0x74, 0x4c, 0x45, 0x4e, 0xf7, 0x68, 0xa1,
	0x07, 0xc8, 0x4a, 0x27, 0x5d, 0xd8, 0x27, 0x30, 0x66, 0x80, 0xe8, 0x58, 0x64, 0x29, 0x56, 0xb7,
	0x52, 0x7a, 0x02, 0x8b, 0x20, 0xee, 0xdc, 0x65, 0x12, 0xe0, 0xb8, 0xf3, 0xf6, 0xc0, 0x2b, 0x50,
	0x1e, 0x45, 0xc3, 0xfc, 0x23, 0x00, 0x8d, 0x93, 0x63, 0xd6, 0xea, 0x1c, 0xe2, 0xee, 0xf4, 0x10,
	0xb4, 0x21, 0x75, 0xee, 0x09, 0x62, 0xbf, 0xc8, 0x92, 0xd9, 0xe3, 0xf4, 0x9b, 0x55, 0xb7, 0x61,
	0xcc, 0x5c, 0xb1, 0x43, 0xbd, 0xe7, 0xe2, 0x44, 0xe4, 0xfa, 0x0a, 0x71, 0x75, 0xd9, 0x72, 0x22,
	0xd7, 0xc2, 0x33, 0x95, 0x2c, 0xee, 0xb3, 0x5d, 0x18, 0x33, 0x90, 0x69, 0x2c, 0xb2, 0x80, 0xc7,
	0xcd, 0x13, 0x85, 0xb1, 0x49, 0x49, 0x2b, 0xbd, 0x25, 0xfd, 0x75, 0x4a, 0xc3, 0xae, 0x42, 0x24,
	0x99, 0x35, 0x12, 0x62, 0x58, 0x38, 0x6b, 0x24, 0xc4, 0x21, 0x68, 0xee, 0x55, 0x12, 0x7e, 0xa5,
	0xf8, 0x6a, 0x2f, 0xe1, 0x05, 0x8d, 0x7e, 0x5b, 0x35, 0x90, 0x70, 0xec, 0x19, 0x4c, 0x58, 0x48,
	0x30, 0x3d, 0xd1, 0x45, 0x91, 0x6a, 0x7a, 0xa2, 0x8b, 0x41, 0xc7, 0xdc, 0x4b, 0xa4, 0x46, 0xa1,
	0x78, 0xa6, 0xa7, 0x1a, 0xd6, 0xb4, 0xf4, 0x77, 0x29, 0x9a, 0x1c, 0xa2, 0xf8, 0x2c, 0x76, 0x32,
	0x2a, 0xc9, 0xde, 0x6d, 0x38, 0xa7, 0xba, 0xd6, 0xa3, 0x3e, 0xeb, 0xa4, 0xcf, 0xdb, 0xc5, 0xf3,
	0x3d, 0xf5, 0x31, 0x21, 0x65, 0xab, 0x16, 0xc0, 0x8c, 0xfd, 0x63, 0x0c, 0xdf, 0x16, 0x42, 0x6a,
	0x4f, 0x27, 0x2b, 0x60, 0x20, 0xc2, 0x1c, 0xb7, 0x57, 0x13, 0x54, 0xf3, 0x36, 0xa9, 0xb9, 0x5e,
	0x7c, 0xad, 0x5f, 0x35, 0x15, 0x10, 0x6c, 0x35, 0x8a, 0x0c, 0x63, 0xdf, 0xa5, 0xa2, 0x80, 0x2f,
	0x13, 0xf2, 0xc4, 0x5e, 0x4a, 0xd6, 0x26, 0x82, 0xe2, 0x72, 0xce, 0xf4, 0xd3, 0x0c, 0x15, 0xbf,
	0x49, 0x8a, 0x5f, 0x2b, 0x16, 0xfa, 0x54, 0x5c, 0x01, 0xb8, 0x56, 0x23, 0x80, 0x2e, 0xf6, 0x75,
	0x4a, 0x83, 0x2b, 0x2d, 0xb0, 0x92, 0x9e, 0x1b, 0x3b, 0xa1, 0xae, 0x9c, 0xd3, 0x3d, 0x5a, 0x1c,
	0x40, 0x4f, 0x85, 0xb5, 0x5a, 0x8d, 0x60, 0xaf, 0xd8, 0x57, 0x06, 0x56, 0xd5, 0x04, 0x14, 0xb1,
	0x58, 0x28, 0x46, 0x40, 0x52, 0xce, 0x72, 0xf7, 0x06, 0xa8, 0xe4, 0x0d, 0x52, 0xf2, 0x6a, 0xf1,
	0x42, 0x4f, 0x25, 0x2d, 0x64, 0xd4, 0xaa, 0x0d, 0x94, 0x62, 0xdf, 0x63, 0xb8, 0x26, 0x23, 0x53,
	0x74, 0xb8, 0x76, 0x44, 0x18, 0xe9, 0x70, 0xed, 0x0c, 0x6e, 0x71, 0x37, 0x49, 0xd1, 0xf7, 0x9d,
	0xf7, 0x7a, 0x2a, 0xda, 0x94, 0x28, 0x07, 0x95, 0x0e, 0x60, 0xa5, 0x3e, 0x1e, 0xd8, 0x97, 0x2f,
	0xb8, 0xfb, 0xdf, 0xe7, 0xab, 0xc7, 0xb7, 0x29, 0x3a, 0x16, 0x8f, 0x01, 0x1e, 0xb4, 0x6d, 0x3b,
	0xa0, 0x62, 0xb4, 0x6d, 0x3b, 0xe1, 0x25, 0xdc, 0x0d, 0x52, 0xf9, 0xae, 0x73, 0xab, 0x7f, 0x95,
	0x69, 0xdf, 0xdd, 0x55, 0xe1, 0x5d, 0x95, 0x31, 0xab, 0xdf, 0x74, 0x47, 0x32, 0x66, 0x7d, 0x3d,
	0x1b, 0xcd, 0x98, 0xcd, 0x2b, 0x55, 0x97, 0x54, 0x3b, 0xee, 0x2e, 0x46, 0x54, 0x93, 0xb7, 0xbd,
	0x66, 0xfe, 0xac, 0x6e, 0xc1, 0xed, 0xfc, 0xd9, 0xb8, 0x98, 0xb7, 0xf3, 0x67, 0xf3, 0xd2, 0xdc,
	0xc8, 0x9f, 0x93, 0xc5, 0xb0, 0x4f, 0x29, 0x7f, 0x56, 0x5d, 0x31, 0xf3, 0x67, 0xa3, 0x1f, 0x0b,
	0x49, 0x64, 0x9d, 0x89, 0xb1, 0xd3, 0x1d, 0xb8, 0x17, 0x9e, 0xc9, 0x08, 0xe0, 0x49, 0xef, 0x84,
	0x75, 0xaf, 0x1c, 0x4d, 0xa9, 0x93, 0xac, 0x16, 0xbf, 0x88, 0x96, 0x02, 0x57, 0xfa, 0x10, 0xf8,
	0x67, 0xe1, 0x6f, 0x98, 0x55, 0x26, 0x14, 0xf1, 0x86, 0x99, 0x68, 0x39, 0x9d, 0xaa, 0x50, 0xe6,
	0x3c, 0xc9, 0x9c, 0x72, 0x21, 0xcc, 0xa9, 0xc8, 0x39, 0x1f, 0xca, 0x5f, 0x35, 0x2b, 0x1a, 0xb3,
	0x9c, 0x60, 0x5e, 0xae, 0xea, 0x0e, 0xc5, 0xae, 0xa1, 0x8d, 0x0d, 0x6c, 0xc8, 0x9c, 0xfd, 0xb1,
	0xf8, 0xdd, 0xb2, 0x52, 0xdb, 0x34, 0xbe, 0xa9, 0xf3, 0x62, 0x22, 0x1d, 0x79, 0x2e, 0x12, 0xcf,
	0x19, 0x36, 0xa5, 0x79, 0x8a, 0x8d, 0xc7, 0x27, 0xe1, 0x4f, 0x93, 0x63, 0x26, 0x89, 0xdd, 0x2c,
	0x6b, 0x93, 0x24, 0xdc, 0x20, 0x4b, 0x09, 0x2b, 0x31, 0x09, 0x7f, 0x8a, 0xf9, 0x84, 0x79, 0x8d,
	0x6c, 0xe4, 0x13, 0x91, 0x1b, 0x67, 0x23, 0x9f, 0x88, 0xde, 0x3b, 0x2b, 0xf6, 0xae, 0xc9, 0x3e,
	0xc0, 0x56, 0xac, 0x42, 0xbf, 0x8c, 0x35, 0xee, 0x7c, 0x99, 0x99, 0x95, 0xd8, 0x17, 0xcc, 0x8e,
	0xd3, 0xa9, 0x4a, 0x27, 0xb5, 0xc5, 0xd9, 0x48, 0x07, 0x0a, 0xed, 0x66, 0x75, 0x95, 0xb0, 0x0b,
	0x01, 0x81, 0xf5, 0xad, 0x6b, 0x5b, 0x76, 0x2c, 0x81, 0x63, 0x98, 0x1f, 0x1d, 0xef, 0x5c, 0x89,
	0x02, 0x7f, 0x4b, 0x02, 0x4f, 0x16, 0xe7, 0xa3, 0x02, 0xad, 0x8c, 0xa8, 0xc9, 0x0f, 0xe6, 0xec,
	0x4b, 0x3f, 0x2d, 0x34, 0xe1, 0xc6, 0xd7, 0x39, 0xde, 0xb9, 0x52, 0x6f, 0x0e, 0xd9, 0xb1, 0x82,
	0x38, 0x4c, 0x2f, 0x3c, 0x0b, 0xcf, 0xdf, 0xf7, 0x0b, 0xbb, 0x92, 0xff, 0x96, 0xc0, 0xf9, 0x18,
	0xf7, 0x41, 0x7a, 0x37, 0x1a, 0xbf, 0x56, 0xd4, 0xbb, 0xd1, 0x84, 0x4b, 0x24, 0xe5, 0x38, 0x67,
	0x9c, 0x0f, 0x4f, 0x35, 0xf9, 0xf3, 0xc1, 0xf2, 0x58, 0x40, 0x30, 0xac, 0xc3, 0x68, 0x9d, 0xfa,
	0x26, 0x5d, 0x1f, 0xe9, 0xd4, 0x37, 0xf1, 0x14, 0x5b, 0x9d, 0xa8, 0x39, 0x93, 0xb2, 0x6f, 0x32,
	0xb3, 0xe0, 0xc2, 0xbe, 0x30, 0xee, 0x59, 0xcd, 0xbc, 0xf2, 0x54, 0xcc, 0x58, 0x91, 0xc4, 0x72,
	0xb9, 0x7b, 0x03, 0xbd, 0x5b, 0x71, 0x98, 0x25, 0x55, 0xa4, 0x8f, 0x28, 0x79, 0x93, 0xff, 0x18,
	0x47, 0x1f, 0xac, 0xb2, 0xc5, 0xd8, 0x41, 0x9d, 0x38, 0x81, 0xd5, 0x13, 0x76, 0xf4, 0x1c, 0xd6,
	0x9c, 0x10, 0x5a, 0x95, 0x6a, 0x81, 0x9f, 0xba, 0xae, 0x4d, 0xff, 0xcb, 0x8f, 0x27, 0x53, 0xff,
	0x8a, 0xff, 0xfe, 0x03, 0xff, 0xfd, 0xed, 0x4f, 0x27, 0x7f, 0xef, 0xd1, 0x08, 0xfd, 0xe7, 0x41,
	0xbf, 0xff, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff, 0xa2, 0x20, 0xaf, 0x1a, 0xd3, 0x48, 0x00, 0x00,
}
